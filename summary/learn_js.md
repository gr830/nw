# learn.javascript.ru

## Введение

### Введение в JavaScript

Изначально JavaScript был создан, чтобы «сделать веб-страницы живыми»

Сегодня JavaScript может выполняться не только в браузере, но и на сервере или на любом другом устройстве, которое имеет специальную программу, называющуюся «движком» JavaScript

Движки сложны. Но основы понять легко.
- Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
- Затем он преобразует («компилирует») скрипт в машинный язык.
- После этого машинный код запускается и работает достаточно быстро.

Возможности JavaScript в браузере ограничены ради безопасности пользователя. 
- JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.
- Различные окна/вкладки не знают друг о друге. «Политика одинакового источника».

Как минимум, три сильные стороны JavaScript:
- Полная интеграция с HTML/CSS.
- Простые вещи делаются просто.
- Поддерживается всеми основными браузерами и включён по умолчанию.

### Справочники и спецификации

Спецификация ECMA содержит самую глубокую, детальную и формализованную информацию о JavaScript

MDN (Mozilla) JavaScript Reference – это справочник с примерами и другой информацией. Хороший источник для получения подробных сведений о функциях языка, методах встроенных объектов и так далее.

Таблицы совместимости - https://caniuse.com – таблицы с информацией о поддержке 

### Редакторы кода

Термином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.

### Консоль разработчика

Но по умолчанию в браузере ошибки не видны.
Для решения задач такого рода в браузер встроены так называемые «Инструменты разработки».

Нажмите F12

## Основы JavaScript

### Привет, мир!

Для серверных сред (например, Node.js), вы можете выполнить скрипт с помощью команды типа "node my.js"

Тег «script»
```html
 <script>
    alert( 'Привет, мир!' );
 </script>

<!-- Внешние скрипты  -->
<script src="/path/to/script.js"></script>
```
- /path/to/script.js – это абсолютный путь от корневой папки
- можно указать относительный путь от текущей страницы. Например, src="script.js"

### Структура кода

- Инструкции – это синтаксические конструкции и команды, которые выполняют действия
- Инструкции могут отделяться точкой с запятой
- В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку
- В некоторых ситуациях новая строка всё же не означает точку с запятой
```js
alert(3 +
1
+ 2);

//будет ошибка
alert('Hello')
[1, 2].forEach(alert);
//alert('Hello')[1, 2].forEach(alert);
```
- Мы рекомендуем ставить точку с запятой между инструкциями, даже если они отделены переносами строк

**Комментарии**
- Ctrl+/ для однострочного комментария 
- Ctrl+Shift+/ – для многострочных комментариев
- Вложенные комментарии не поддерживаются! Не может быть /*...*/ внутри /*...*/.
```js
// Этот комментарий занимает всю строку
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
```

### Строгий режим — "use strict"

- Убедитесь, что «use strict» находится в начале
- Нет никакого способа отменить use strict
- Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать, они автоматически включают строгий режим
```js
"use strict";
// этот код работает в современном режиме
```

```js
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке
"use strict";
```

### Переменные

Переменная – это «именованное хранилище» для данных. 

```js
let message;
message = 'Hello!';
alert(message); // показывает содержимое переменной

//можем объявить несколько переменных в одной строке
let user = 'John', age = 25, message = 'Hello';

//____
//можем объявить две переменные и скопировать данные из одной в другую
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!

//_____
//Повторное объявление вызывает ошибку
let message = "Это";
let message = "Другое"; // SyntaxError: 'message'

//____
//Это плохая практика, которая приводит к ошибке в строгом режиме:
"use strict";
num = 5; // ошибка: num is not defined
```

**Имена переменных**
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.
- обычно используется верблюжья нотация - myVeryLongName
- дефис '-' не разрешён в имени
- Регистр имеет значение
- Нелатинские буквы разрешены, но не рекомендуются
- Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

**Константы**

- Их нельзя изменить. Попытка сделать это приведёт к ошибке
```js
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!

//____
//Константы в верхнем регистре - константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений
const COLOR_RED = "#F00";
```

**Придумывайте правильные имена**

- ясный и понятный смысл
- говорить о том, какие данные в ней хранятся

**Итого**

- let – это современный способ объявления.
- var – это устаревший способ объявления
- const – похоже на let, но значение переменной не может изменяться.

### Типы данных

Есть восемь основных типов данных в JavaScript

**Число**

- представляет как целочисленные значения, так и числа с плавающей точкой
- cуществует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание -
-  существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

```js
let n = 123;
n = 12.345;
alert( 1 / 0 ); // Infinity

//NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
//Любая математическая операция с NaN возвращает NaN
"не число" / 2 // NaN
alert( NaN + 1 ); 
```

**BigInt**

- все нечетные целые числа, большие чем (253-1), вообще не могут храниться в типе number
- необходимо добавить n в конец

```js
const bigInt = 1234567890123456789012345678901234567890n;
```

**Строка**

```js
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
//Обратные же кавычки имеют расширенную функциональность
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
```

**Булевый (логический) тип**

- true (истина) и false (ложь).

```js
let isGreater = 4 > 1;// true (результатом сравнения будет "да")
```

**Значение «null»**

- представляет собой «ничего», «пусто» или «значение неизвестно».
```js
let age = null;
```

**Значение «undefined»**
- сли переменная объявлена, но ей не присвоено никакого значения
```js
let age;
alert(age); // выведет "undefined"
```

**Объекты и символы**

Тип object (объект) – особенный.
- Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

**Тип symbol**

Используется для создания уникальных идентификаторов в объекта.

**Оператор typeof**

```js
// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже),скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения
typeof(5) // Также выведет "number

typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1) / Math — это встроенный объект
typeof null // "object"  (2) / Это официально признанная ошибка в typeof
typeof alert // "function"  (3) / alert является функцие / Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function"
```

### Взаимодействие: alert, prompt, confirm

- alert- она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК»
```js
alert("Hello");
```
- prompt - отобразит модальное окно с текстом,default
необязательный второй параметр, который устанавливает начальное значен
```js
let age = prompt('Сколько тебе лет?', 100);
```
- confirm - функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
```js
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK
```

### Преобразование типов

**Строковое преобразование**
```js
let value = true;
value = String(value); // теперь value это строка "true
```

**Численное преобразование**

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.

```js
alert( "6" / "2" ); // 3, строки преобразуются в числа

//явно преобразовать value
let str = "123";
let num = Number(str); // становится числом 1
```

- undefined - NaN
- null - 0
- true / false	1 /  - 0
- string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

**Логическое преобразование**

Правило преобразования:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
- Все остальные значения становятся true
```js
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
```

### Базовые операторы, математика

**Термины: «унарный», «бинарный», «операнд»**

Операнд – то, к чему применяется оператор. 

Унарным называется оператор, который применяется к одному операнду
```js
let x = 1;
x = -x;
```

Бинарным называется оператор, который применяется к двум операндам
```js
y - x
```

**Математика**

- Сложение +,
- Вычитание -,
- Умножение *,
- Деление /,
- Взятие остатка от деления %,
- Возведение в степень **

```js
5 % 2 ; // 1, остаток от деления 5 на 2
2 ** 2 ; // 2² = 4
 4 ** (1/2) ; // 2 (степень 1/2 эквивалентна взятию квадратного корня)
```

### Сложение строк при помощи бинарного +

```js
let s = "моя" + "строка"; // моястрока
'1' + 2 ; // "12"
2 + 2 + '1' ; // будет "41", а не "221"
```

Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
```js
6 - '2' ; // 4, '2'
```

**Приведение к числу, унарный +**

- Если операнд не число, унарный плюс преобразует его в число.
```js
+true ; // 1

let apples = "2";
let oranges = "3";
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
```

**Приоритет операторов**

В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

**Присваивание**

Один из самых низких приоритетов: 2
```js
let x = 2 * 2 + 1; // 5
```

Присваивание = возвращает значение
```js
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
```

Присваивание по цепочке
```js
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Сокращённая арифметика с присваиванием
```js
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 
```

**Инкремент/декремент**

Инкремент ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
```

Декремент -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
```

Операторы ++ и -- могут быть расположены не только после, но и до переменной.
- Когда оператор идёт после переменной — это «постфиксная форма»: counter++,постфиксная форма возвращает старое (до увеличения/уменьшения числа)
```js
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++
alert(a); // 1
```
- «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
```js
let counter = 1;
let a = ++counter; // (*)
alert(a); // 2
```

Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать.Если хочется тут же использовать результат, то нужна префиксная форма.

Операторы ++/-- могут также использоваться внутри выражений.
```js
let counter = 1;
alert( 2 * ++counter ); 
```

**Побитовые операторы**

Побитовые операторы работают с 32-разрядными целыми числами
- AND(и) ( & )
- OR(или) ( | )
- XOR(побитовое исключающее или) ( ^ )
- NOT(не) ( ~ )
- LEFT SHIFT(левый сдвиг) ( << )
- RIGHT SHIFT(правый сдвиг) ( >> )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

**Оператор «запятая»**

- написания более короткого кода
- но возвращается результат только последнего
```js
let a = (1 + 2, 3 + 4);// 7 (результат вычисления 3 + 4)

//Запятая имеет очень низкий приоритет,ниже =
a = 1 + 2, 3 + 4;
alert(a); // 3 

// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {}
```

### Операторы сравнения

**Результат сравнения имеет логический тип**

- true – означает «да», «верно», «истина».
- false – означает «нет», «неверно», «ложь

```js
2 > 1 ;  // true
```

**Сравнение строк**

- строки сравниваются посимвольно
- К равна К.
- о равна о.
- т больше, чем д. На этом сравнение заканчивается. Первая строка больше.
```js
'Я' > 'А' ; // true
'Коты' > 'Кода' ; // true
```

**Сравнение разных типов**

- При сравнении значений разных типов JavaScript приводит каждое из них к числу.

```js
'2' > 1 ; // true, строка '2' становится числом 2
'01' == 1 ; // true, строка '01' становится числом 1

let a = 0;
Boolean(a); // false
let b = "0";
Boolean(b); // true
a == b; // true
```

**Строгое сравнение**

Оператор строгого равенства === проверяет равенство без приведения типов.
```js
0 == false ; // true
0 === false ; // false, так как сравниваются разные типы
```

**Сравнение с null и undefined**

Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

```js
null === undefined ; // false

null == 0 ; // (2) false
//Сравнения преобразуют null в число
alert( null >= 0 ); // (3) true
```

Значение undefined несравнимо с другими значениями:
- undefined преобразуется в NaN
```js
undefined > 0 ; // false (1)
```

**Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.**

### Условное ветвление: if, '?'

**Инструкция «if»**

Инструкция if(...) вычисляет условие в скобках и, если результат true

```js
if (year == 2015) alert( 'Вы правы!' );

if (year == 2015) {
   //...
}
```

**Преобразование к логическому типу**

- if (…) вычисляет выражение в скобках и преобразует результат к логическому типу
- Инструкция if может содержать необязательный блок «else» («иначе»)
- Иногда нужно проверить несколько вариантов условия. Для этого используется блок else if

```js
let year = 2013
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

**Условный оператор „?“**

- Его также называют тернарный

```js
let accessAllowed = (age > 18) ? true : false;
```

**Несколько операторов „?“**

```js
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
```

### Логические операторы

- || (ИЛИ)
- && (И) 
- ! (НЕ)
- ?? (Оператор нулевого слияния)

**|| (ИЛИ)**

-  в случае, если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается fals

```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

**ИЛИ "||" находит первое истинное значение**

- цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

```js
undefined || null || 0 ; // 0 (поскольку все ложно, возвращается последнее значение)

//Если бы все переменные были ложными, в качестве результата мы бы наблюдали "Аноним".
let firstName = "";
let lastName = "";
let nickName = "Суперкодер";
alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```

**||= (Логическое присваивание ИЛИ)**

- Если a ложно, присваивает a значение b
```js
a || (a = b);

//__
let johnHasCar = false;
johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")
alert( johnHasCar ); // "У Джона нет машины!"

//можем переписать приведённые выше примеры с использованием обычного if
let johnHasCar = false;
if (johnHasCar == false) {
  johnHasCar = "У Джона нет машины!";
}
alert(johnHasCar); // "У Джона нет машины!"
```

**&& (И)**

```js
//В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Оператор && выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. - Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

```js
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3
```

Несмотря на то, что вариант с && кажется более коротким, if более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать if, если нам нужно if, и использовать &&, если нам нужно И.

**&&= (Логическое присваивание И)**

&&= присвоит a значение b только в том случае, если a истинно.

```js
a &&= b; //a && (a = b);
```

**! (НЕ)**

- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.

```js
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ !! используют для преобразования значений к логическому типу:
```js
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```

### Операторы нулевого слияния и присваивания: '??', '??='

- оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.


Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.
```js
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
```

Приоритет оператора ?? такой же, как и у ||. Они оба равны 3 в таблице на MDN.

По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

Можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```

**Оператор нулевого присваивания (??=)**

??= присвоит x значение y только в том случае, если x не определено (null/undefined).
```js
let userAge = null;
userAge ??= 18;
alert(userAge) // 18
```

### Циклы while и for

**Цикл «while»**

- Код из тела цикла выполняется, пока условие condition истинно
- условие while вычисляется и преобразуется в логическое значение
```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки
```js
while (i) alert(i--);
```

**Цикл «do…while»**

Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

**Цикл «for»**
- начало	let i = 0	Выполняется один раз при входе в цикл
- условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
- тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
- шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
```js
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

**Пропуск частей «for»**

```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

//__
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
//Это сделает цикл аналогичным while (i < 3).
```

**Прерывание цикла: «break»**

Полностью прекращает выполнение цикла

```js
let sum = 0;

while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );
```

**Переход к следующей итерации: continue**

При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

```js
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

**Нельзя использовать break/continue справа от оператора „?“**

синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?
```js
(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
```

**Метки для break/continue**

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

```js
// outer:
// for (let i = 0; i < 3; i++) { ... }
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    //// не прыгает к метке ниже
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}
```

### Конструкция "switch"

Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

```js
switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

//Любое выражение может быть аргументом
switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}
```

**Группировка «case»**

```js
switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
```

**Тип имеет значение**

Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

### Функции

- Повторять одно и то же действие во многих частях программы.
- Одно из главных предназначений функций: избавление от дублирования кода.

**Объявление функции**

```js
function имя(параметры) {
  //...тело...
}
```

**Локальные переменные**

Переменные, объявленные внутри функции, видны только внутри этой функции
```js
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная
  alert( message );
}
showMessage(); // Привет, я JavaScript!
alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции
```

**Внешние переменные**

У функции есть доступ к внешним переменным

Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

```js
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // Привет, Вася
```

**Параметры**

- Функция всегда получает только копию значения
- Параметр – это переменная, указанная в круглых скобках в объявлении функции.
- Аргумент – это значение, которое передаётся функции при её вызове.
```js
function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}
```

**Значения по умолчанию**

```js
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}

//параметров по умолчанию в ранних версиях JavaScript
function showMessage(from, text) {
  if (text === undefined) {
    text = 'текст не добавлен';
  }
}

function showMessage(from, text) {
  text = text || 'текст не добавлен';
}
```

**Возврат значения**

Функция может вернуть результат

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код

```js
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2); // 3

function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

//Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции
//Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;//undefined
  }
}

//Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

**Bыбор имени функции**

Функция – это действие. Поэтому имя функции обычно является глаголом
Функции, начинающиеся с…
- "get…" – возвращают значение,
- "calc…" – что-то вычисляют,
- "create…" – что-то создают,
- "check…" – что-то проверяют и возвращают логическое значение, и т.д.

**Одна функция – одно действие**

Функции должны быть короткими и делать только что-то одно.

### Function Expression

Функциональное Выражение
- создать функцию и поместить её в переменную

```js
let sayHi = function() {
  alert( "Привет" );
};
```

**Функция – это значение**

```js
function sayHi() {
  alert( "Привет" );
}
alert( sayHi ); // выведет код функции

//Мы можем скопировать функцию в другую переменную
let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет 

//выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi
```

**Функции-«колбэки»**

Аргументы showOk и showCancel функции ask называются функциями-колбэками или просто колбэками.

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "Вы согласны." );
}
function showCancel() {
  alert( "Вы отменили выполнение." );
}
// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

//__
//Здесь функции объявляются прямо внутри вызова ask(...). У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи ask
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```

**Function Expression в сравнении с Function Declaration**

- Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
- Function Declaration может быть вызвана раньше, чем она объявлена.
- Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них.

```js
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```

В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
```js
//Function Declaration видимо только внутри блока код
if (age < 18) {
  function welcome() {
    alert("Привет!");
  }
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}
// ...не работает
welcome(); // Error: welcome is not defined

//___Верным подходом будет объявленние снаружи
let welcome;
if (age < 18) {
  welcome = function() {
    alert("Привет!");
  };
} else {
  welcome = function() {
    alert("Здравствуйте!");
  };
}
welcome(); 
```

### Стрелочные функции, основы

```js
let sum = (a, b) => a + b;

//Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить
let double = n => n * 2;
```

**Многострочные стрелочные функции**

```js
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};
```

## Качество кода

### Отладка в браузере

Отладка – это процесс поиска и исправления ошибок в скрипте. 

**Панель «Исходный код» («Sources»)**

- В зоне File Navigator (панель для навигации файлов) 
- Зона Code Editor
- зона JavaScript Debuggin

**Точки останова (breakpoints)**
- Точка останова – это участок кода, где отладчик автоматически приостановит исполнение JavaScript
- щёлкните на номере строки, вы поставили точку останова
- Пока исполнение поставлено «на паузу», мы можем просмотреть текущие значения переменных

**Команда debugger**

```js
function hello(name) {
  let phrase = `Привет, ${name}!`;
  debugger;  // <-- тут отладчик остановится
  say(phrase);
}
```

**Остановимся и оглядимся**

- Для начала отладки (после того, как мы поставили точки останова) проще всего её перезагрузить
- Watch– показывает текущие значения для любых выражений
- Call Stack – показывает цепочку вложенных вызовов
- Scope показывает текущие переменные
- В Global перечисляются глобальные переменные

**Пошаговое выполнение скрипта**

-  –> «Resume»: продолжить выполнение, быстрая клавиша F8.Выполнение кода возобновилось, дошло до другой точки останова
- «Step»: выполнить следующую команду, быстрая клавиша F9.Выполняет следующую инструкцию,«Step» игнорирует асинхронные действия
- «Step over»: выполнить следующую команду, но не заходя внутрь функции, быстрая клавиша F10, выполняет вызов вложенной функции незаметно для нас, пропуская её внутренний код.
- «Step into», быстрая клавиша F11.«Step into» входит в их код, ожидая асинхронные действия
- «Step out»: продолжить выполнение до завершения текущей функции, быстрая клавиша Shift+F11.Продолжает выполнение и останавливает его в самой последней строке текущей функции.
- активировать/деактивировать все точки останова(breakpoints).
- включить/отключить автоматическую паузу в случае ошибки.

**Логирование**

Чтобы вывести что-то на консоль из нашего кода, существует функция console.log.
```js
console.log("value,", i);
```

### Советы по стилю кода

**Синтаксис**

```js
//_Фигурные скобки
if (n < 0) {
  alert(`Степень ${n} не поддерживается`);
}

```

**Длина строки**

Максимальную длину строки согласовывают в команде. Обычно это 80 или 120 символов

**Отступы**

- Горизонтальные отступы: 2 или 4 пробела.
- Вертикальные отступы: пустые строки для разбивки кода на «логические блоки».
```js
function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
```

**Точка с запятой**

Должны присутствовать после каждого выражения

**Уровни вложенности**

Уровней вложенности должно быть немного.

```js
//вариант является более читабельным, потому что «особый случай» n < 0 обрабатывается на ранней стадии
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

**Размещение функций**

```js
//Объявить функции перед кодом, который их вызове
function createElement() {
  //...
}

// код, который использует их
let elem = createElement();
setHandler(elem);
walkAround();
```

Некоторые популярные руководства:
- Google JavaScript Style Guide
- Airbnb JavaScript Style Guide (есть перевод)
- Idiomatic.JS (есть перевод)
- StandardJS
- (и ещё множество других)

**Автоматизированные средства проверки (линтеры)**

Автоматически проверять стиль вашего кода и вносить предложения по его улучшению.

- JSLint – проверяет код на соответствие стилю JSLint
- ESLint – пожалуй, самый современный линтер

### Комментарии

- могут быть однострочными, начинающимися с //, и многострочными: /* ... */
- в хорошем коде количество «объясняющих» комментариев должно быть минимальным
- Функция сама становится комментарием. Такой код называется самодокументированным.
- В целом мы должны стараться писать простой и самодокументированный код

**Хорошие комментарии**

Есть специальный синтаксис JSDoc для документирования функций
```js
/**
 * Возвращает x, возведённое в n-ную степень.
 *
 * @param {number} x Возводимое в степень число.
 * @param {number} n Степень, должна быть натуральным числом.
 * @return {number} x, возведённое в n-ную степень.
 */
function pow(x, n) {
  //...
}
```

### Ниндзя-код

- использовать короткие имена переменных
- Пишите «как короче», а не как понятнее
- Используйте сокращения
- Будьте абстрактны при выборе имени.
- Добавляйте подчёркивания _ и __ к именам переменных. Например, _name или __value,желательно, чтобы их смысл был известен только вам.
- Пусть все видят, какими замечательными сущностями вы оперируете! Имена superElement, megaFrame и niceItem
- Перекрывайте внешние переменные

### Тесты

- При тестировании кода ручными перезапусками легко упустить что-нибудь важное.
- Автоматическое тестирование означает, что тесты пишутся отдельно, в дополнение к коду. Они по-разному запускают наши функции и сравнивают результат с ожидаемым.

**Behavior Driven Development (BDD)**

В BDD сначала пишут спецификацию, а потом реализацию.

Разработка проходит итеративно. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и т.д.

```js
//__test.js
//Какую функциональность мы описываем
describe("pow", function() {
  
  //описываем конкретный способ использования функции
  it("возводит в степень n", function() {

    //используются для проверки
    assert.equal(pow(2, 3), 8);
  });

});
```

!Один тест проверяет одну вещь.

**вложенные блоки describe**

- Группировка производится вложенными блоками describe
- Вложенные describe образуют новую подгруппу тестов

Мы можем задать before/after функции, которые будут выполняться до/после тестов
```js
describe("тест", function() {
  before(() => alert("Тестирование началось – перед тестами"));
  after(() => alert("Тестирование закончилось – после всех тестов"));
  it('тест 1', () => alert(1));
  it('тест 2', () => alert(2));
});
```

### Полифилы

- Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

**Babel**

- Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.

Таким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер и добавить полифил.

## Объекты: основы

### Объекты

- {…} с необязательным списком свойств
- Свойство – это пара «ключ: значение», где ключ – это строка

```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```

**Литералы и свойства**

- При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение
- Значение может быть любого типа

```js
let user = {   
  name: "John",  
  age: 30    
};

// получаем свойства объекта:
user.name ; // John

//Значение может быть любого типа. Давайте добавим свойство 
user.isAdmin = true;

//удаления свойства
delete user.age;
```

Cвойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки
```js
let user = {
  "likes birds": true  
};
```

Объект, объявленный через const, может быть изменён
- const защищает от изменений только саму переменную user, а не её содержимое.
```js
const user = {
  name: "John"
};
user.name = "Pete"; // (*)
alert(user.name); // Pete
```

**Квадратные скобки**

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает.Для таких случаев существует альтернативный способ.
```js
let user = {};
user["likes birds"] = true;
alert(user["likes birds"]); // true
```

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
```js
let key = "likes birds";
user[key] = true;
```

**Вычисляемые свойства**

```js
let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {
  [fruit]: 5, 
};
alert( bag.apple ); // 5, если fruit="apple"

//более сложные выражения
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

**Свойство из переменной**

```js
function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}
```

**Ограничения на имена свойств**

- нет никаких ограничений к именам свойств
- Есть небольшой подводный камень, связанный со специальным свойством proto Мы не можем установить его в необъектное значение

**Проверка существования свойства, оператор «in»**

```js
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует

//В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит и нужно использовать "in".
let obj = {
  test: undefined
};
alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```

**Цикл "for..in"**

```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```

**Упорядочение свойств объекта**

Упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. А вот свойства "+49" или "1.2" таковыми не являются.Если ключи не целочисленные, то они перебираются в порядке создания
```js
let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};
for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
```

### Копирование объектов и ссылки

Отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

**Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.**

**При копировании переменной объекта копируется ссылка, но сам объект не дублируется.**

```js
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
```

**Сравнение по ссылке**

Два объекта равны только в том случае, если это один и тот же объект.

```js
let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true

//___
let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false
```

**Клонирование и объединение, Object.assign**

```js
//__1
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект
// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные
alert( user.name ); // все ещё John в первоначальном объекте

//__метод Object.assign
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }

//Если скопированное имя свойства уже существует, оно будет перезаписано
let user = { name: "John" };
Object.assign(user, { name: "Pete" });
alert(user.name); // теперь user = { name: "Pete" }

let user = {
  name: "John",
  age: 30
};
let clone = Object.assign({}, user);

//оператора расширения 
clone = {...user}
```

**Вложенное клонирование**

Это называется «глубоким клонированием».

Метод structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерам.

### Сборка мусора

Основной концепцией управления памятью в JavaScript является принцип достижимости.
- «достижимые» значения – это те, которые доступны или используются.
- Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
-  Объект становится недостижимым - cборщик мусора удалит эти данные и освободит память.
- Бывший объект  был отсоединён от корня, на него больше нет ссылки, поэтому весь «остров» становится недостижимым и будет удалён.

**Внутренние алгоритмы**

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

### Методы объекта, "this"


**Сокращённая запись метода**
```js
user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
  }
};
```

**Ключевое слово «this» в методах**

- Значение this – это объект «перед точкой», который используется для вызова метода.

```js
let user = {
  name: "John",
  age: 30,
  sayHi() {
    // "this" - это "текущий объект".
    alert(this.name);
  }
};
user.sayHi(); // John
```

**«this» не является фиксированным**

Значение this вычисляется во время выполнения кода, в зависимости от контекста.

Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj.
```js
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}
// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;
```

**Вызов без объекта**

В строгом режиме ("use strict") в таком коде значением this будет являться undefined
```js
function sayHi() {
  alert(this);
}
sayHi(); // undefined
```

В нестрогом режиме значением this в таком случае будет глобальный объект window

**У стрелочных функций нет «this»**

```js
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya
```

### Конструктор, оператор "new"

Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих

**Функция-конструктор**

- Функция-конструктор должна выполняться только с помощью оператора "new"
- Создаётся новый пустой объект, и он присваивается this.
- Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
- Возвращается значение this
```js
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
let user = new User("Jack");
alert(user.name); // Jack
alert(user.isAdmin); // false
```

Технически любая функция (кроме стрелочных функций, поскольку у них нет this) может использоваться в качестве конструктора.

Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:
```js
let user = new function() {
  this.name = "John";
  this.isAdmin = false;
};
```

**Проверка на вызов в режиме конструктора: new.target**

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
```js
function User() {
  alert(new.target);
}
// без "new":
User(); // undefined
// с "new":
new User(); // function User { ... }

//__
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }

  this.name = name;
}
let john = User("John"); // переадресовывает вызов на new User
alert(john.name); // Joh
```

**Возврат значения из конструктора, return**

Return с объектом возвращает этот объект, во всех остальных случаях возвращается this
```js
function BigUser() {
  this.name = "John";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект
```

Обычно у конструкторов отсутствует return. Здесь мы упомянули особое поведение

**Создание методов в конструкторе**

```js
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}
let john = new User("John");
john.sayHi(); // Меня зовут: John
/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```
### Опциональная цепочка '?.'

?. немедленно останавливает вычисление, если левая часть не существуе

```js
let user = {}; // пользователь без свойства "address"
alert(user.address.street); // Ошибка!
```

**Опциональная цепочка**

Обратите внимание: синтаксис ?. делает необязательным значение перед ним, но не какое-либо последующее.

```js
let user = {}; // пользователь без адреса
alert( user?.address?.street ); // undefined (без ошибки)
```

Если слишком часто использовать ?., ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.

Переменная перед ?. должна быть объявлена
```js
// ReferenceError: user is not defined
user?.address;
```

**Другие варианты применения: ?.(), ?.[]**

Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.

```js
let userAdmin = {
  admin() {
    alert("Я админ");
  }
};
let userGuest = {};
userAdmin.admin?.(); // Я админ

//__
let key = "firstName";
let user1 = {
  firstName: "John"
};
let user2 = null;
alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
```

Мы можем использовать "?." для безопасного чтения и удаления, но не для записи Опциональна
```js
let user = null;
user?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"
```

### Тип данных Symbol

«Символ» представляет собой уникальный идентификатор.
```js
// Создаём новый символ - id
let id = Symbol();

// Создаём символ id с описанием (именем) "id"
//Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы
let id = Symbol("id");

//Символы не преобразуются автоматически в строки
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

//необходимо явно преобразовать его с помощью метода .toString()
let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

//вывести только описание
let id = Symbol("id");
alert(id.description); // id
```

**«Скрытые» свойства**

```js
let user = {
  name: "Вася"
};
let id = Symbol("id");
user[id] = 1;
alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
```

**Символы в литеральном объекте**

```js
let id = Symbol("id");
let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
```

**Символы игнорируются циклом for…in**

- А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства

**Глобальные символы**

- Иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью
- Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже
```js
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true

//возвращает его имя .keyFor()
let sym = Symbol.for("name");
alert( Symbol.keyFor(sym) ); // name
```

**Системные символы**

- Symbol.hasInstance
- Symbol.isConcatSpreadable
- Symbol.iterator
- Symbol.toPrimitive
- …и так далее.

### Преобразование объектов в примитивы

**Правила преобразования**
- Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
- Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции.
- Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

**Хинты**

Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

-"string"
```js
// вывод
alert(obj);
// используем объект в качестве ключа
anotherObj[obj] = 123;
```
- "number"
```js
// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;
```
- "default" - Происходит редко, когда оператор «не уверен», какой тип ожидать (для некоторых других операторов, обычно объекты реализуют его как "number")

Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
- Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
- Иначе, если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
- Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

**Symbol.toPrimitive**

Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};
// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

**toString/valueOf**
- Метод toString возвращает строку "[object Object]".
- Метод valueOf возвращает сам объект.
```js
let user = {name: "John"};
alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

применим эти методы для настройки преобразован
```js
let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};
alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

**Преобразование может вернуть любой примитивный тип**

Нет никакого контроля над тем, вернёться

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект

**Дальнейшие преобразования**

```js
let obj = {
  // toString обрабатывает все преобразования в случае отсутствия других методов
  toString() {
    return "2";
  }
};
alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом

//__
let obj = {
  toString() {
    return "2";
  }
};
alert(obj + 2); // "22" ("2" + 2), преобразование к примитиву вернуло строку => конкатенация
```

## Типы данных

### Методы примитивов

JavaScript позволяет нам работать с примитивными типами данных – строками, числами и т.д., как будто они являются объектами. 

Есть 7 примитивных типов: string, number, boolean, symbol, null, undefined и bigint

Объект
- Может хранить множество значений как свойства
- Объекты «тяжелее» примитивов. Они нуждаются в дополнительных ресурсах для поддержания внутренней структуры.

**Примитив как объект**
- Чтобы это работало, при таком доступе создаётся специальный «объект-обёртка», который предоставляет нужную функциональность, а после удаляется.
- Каждый примитив имеет свой собственный «объект-обёртку», которые называются: String, Number, Boolean, Symbol и BigInt.
- В момент обращения к его свойству, создаётся специальный объект
- Этот метод запускается и возвращает новую строку
- Специальный объект удаляется
- Получается, что примитивы могут предоставлять методы, и в то же время оставаться «лёгкими»

```js
let num = 1.23456;
alert( num.toFixed(2) ); // 1.23
```

**Конструкторы String/Number/Boolean предназначены только для внутреннего пользования**
-  не рекомендуется 
```js
alert( typeof 0 ); // "число"
alert( typeof new Number(0) ); // "object"!
```
- без оператора new – вполне разумно и полезно
```js
let num = Number("123"); // превращает строку в число
```

**null/undefined не имеют методов**
-  являются исключениями. 

### Числа

два типа чисел
- 64-битном формате IEEE-754, который также называют числа с плавающей точкой
- BigInt числа дают возможность работать с целыми числами произвольной длины

**Способы записи числа**
- Символ нижнего подчёркивания _ – это «синтаксический сахар»,делает число более читабельным
```js
let billion = 1_000_000_000
```
- "e" и указать необходимое количество нулей
```js
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей
let ms = 1e-6; // шесть нулей слева от 1 0.000006
```

**Шестнадцатеричные, двоичные и восьмеричные числа**

```js
//широко используются в JavaScript для представления цвет
alert( 0xff ); // 255

let a = 0b11111111; // двоичная (бинарная) форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255

alert( a == b ); // true, с двух сторон число 255
```

**toString(base)**

- Метод num.toString(base) возвращает строковое представление числа num в системе счисления base
- base может варьироваться от 2 до 36
```js
let num = 255;
alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 1111111

//Две точки для вызова метода
//нам надо вызвать метод непосредственно на числе
//можно записать как (123456).toString(36)
alert( 123456..toString(36) ); // 2n9c
```

**Округление**
 - Math.floor.
Округление в меньшую сторону: 3.1 становится 3, а -1.1 — -2.
- Math.ceil.
Округление в большую сторону: 3.1 становится 4, а -1.1 — -1.
- Math.round.
Округление до ближайшего целого: 3.1 становится 3, 3.6 — 4, а -1.1 — -1.
- Math.trunc (не поддерживается в Internet Explorer).
Производит удаление дробной части без округления: 3.1 становится 3, а -1.1 — -1.
- Метод toFixed(n) округляет число до n знаков после запятой
```js
//результатом toFixed является строка
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```

**Неточные вычисления**

- Число хранится в памяти в бинарной форме, как последовательность бит – единиц и нулей,являются бесконечной дробью в двоичной форме
- В JavaScript нет возможности хранить одну третью в десятичной системе счисление 1/3 -> 0.33333(3) / или деление на 2 обязательно сработает, а 1/10 становится бесконечной дробью.
```js
alert( 0.1.toFixed(20) ); // 0.10000000000000000555
```
- И когда мы суммируем 2 числа, их «неточности» тоже суммируются.
- обойти проблему
```js
let sum = 0.1 + 0.2;
alert( +sum.toFixed(2) ); // 0.3
```

**Проверка: isFinite и isNaN**

- Infinity (и -Infinity) — особенное численное значение, которое ведёт себя в точности как математическая бесконечность ∞.
- NaN представляет ошибку

```js
// является ли оно NaN
alert( isNaN("str") ); // true
//Значение NaN уникально
alert( NaN === NaN ); // false

//isFinite(value) преобразует аргумент в число и возвращает true, если оно является обычным числом, т.е. не NaN/Infinity/-Infinity
alert( isFinite("15") ); // true
alert( isFinite("str") ); // false, потому что специальное значение: NaN
alert( isFinite(Infinity) ); // false, потому что специальное значение: Infinity
```

Методы Number.isNaN и Number.isFinite – это более «строгие» версии - принадлежит ли он к типу number.Number.isNaN(value) возвращает true только в том случае, если аргумент принадлежит к типу number и является NaN
```js
// Обратите внимание на разный результат:
alert( Number.isNaN("str") ); // false, так как "str" является строкой, а не числом
alert( isNaN("str") ); // true, так как isNaN сначала преобразует строку "str" в число и в результате преобразования получает NaN
```

**Сравнение Object.is**
- Работает с NaN: Object.is(NaN, NaN) === true, здесь он хорош.
- Значения 0 и -0 разные: Object.is(0, -0) === false

**parseInt и parseFloat**
- Для явного преобразования к числу можно использовать + или Number()
- Функция parseInt возвращает целое число, а parseFloat возвращает число с плавающей точкой
```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
alert( parseInt('0xff', 16) ); // 255 - второй параметр. Он определяет систему счисления
```

**Другие математические функции**

В JavaScript встроен объект Math, который содержит различные математические функции
```js
alert( Math.random() ); // 0.1234567894322
alert( Math.max(3, 5, -10, 0, 1) ); // 5
alert( Math.pow(2, 10) ); // 2 в степени 10 = 1024
```

### Строки

Внутренний формат для строк — всегда UTF-16
```js
let single = 'single-quoted';
let double = "double-quoted";

//сможем вставлять произвольные выражения, обернув их в ${…}
let backticks = `backticks`;
let guestList = `Guests:
 * John
 * Pete
 * Mary
`;
```

**Спецсимволы**

- «символ перевода строки», который записывается как \n
```js
// перевод строки добавлен с помощью символа перевода строки
let str1 = "Hello\nWorld";

// многострочная строка, созданная с использованием обратных кавычек
let str2 = `Hello
World`;
```
- Есть и другие, реже используемые спецсимволы
- все спецсимволы начинаются с обратного слеша, \ — так называемого «символа экранирования».
```js
alert( 'I\'m the Walrus!' ); // I'm the Walrus!

//если нам надо добавить в строку собственно сам обратный слеш 
alert( `The backslash: \\` ); // The backslash: \
```

**Длина строки**
- это числовое свойство, а не функция, добавлять скобки не нужно
```js
alert( `My\n`.length ); // 3
```

**Доступ к символам**

```js
let str = `Hello`;
// получаем первый символ
alert( str[0] ); // H
alert( str.at(0) ); // H
// получаем последний символ
alert( str[str.length - 1] ); // o
alert( str.at(-1) ); // o
```

можно перебрать строку посимвольно
```js
for (let char of "Hello") {
  alert(char); // H,e,l,l,o (char — сначала "H", потом "e", потом "l" и т.д.)
}
```

**Строки неизменяемы**
- Можно создать новую строку
```js
let str = 'Hi';
str[0] = 'h'; // ошибка
```

**Изменение регистра**

```js
alert( 'Interface'.toUpperCase() ); // INTERFACE
alert( 'Interface'[0].toLowerCase() ); // 'i
```

**Поиск подстроки**
- Он ищет подстроку substr в строке str, начиная с позиции pos, и возвращает позицию, на которой располагается совпадение, либо -1 при отсутствии совпадений.
```js
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
alert( str.indexOf("id") ); // 1, подстрока "id" найдена на позиции 1 (..idget with id)

//второй аргумент позволяет начать поиск с определённой позиции.Например, первое вхождение "id" — на позиции 1. Для того, чтобы найти следующее, начнём поиск с позиции 2:
let str = 'Widget with id';
alert( str.indexOf('id', 2) ) // 12
```

Чтобы найти все вхождения подстроки, нужно запустить indexOf в цикле
```js
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
```

Также есть похожий метод str.lastIndexOf(substr, position), который ищет с конца строки к её началу.

**Трюк с побитовым НЕ**
```js
alert( ~2 ); // -3, то же, что -(2+1)

//Просто запомните: if (~str.indexOf(…)) означает «если найдено
```

**includes, startsWith, endsWith**
- Методы str.startsWith и str.endsWith проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой
```js
alert( "Widget with id".includes("Widget") ); // true
alert( "Midget".includes("id", 3) ); // false, поиск начат с позиции 3
```

**Получение подстроки**

В JavaScript есть 3 метода для получения подстроки: substring, substr и slice.
- Из двух других вариантов, slice более гибок, он поддерживает отрицательные аргументы, и его короче писать. Так что, в принципе, можно запомнить только его
```js
let str = "stringify";
// 'strin', символы от 0 до 5 (не включая 5)
alert( str.slice(0, 5) );
// 's', от 0 до 1, не включая 1, т. е. только один символ на позиции 0
alert( str.slice(0, 1) );
let str = "stringify";
// начинаем с позиции 4 справа, а заканчиваем на позиции 1 справа
alert( str.slice(-4, -1) ); // gif

//Это — почти то же, что и slice, но можно задавать start больше end,нет отрицательных значений
alert( str.substring(2, 6) ); // "ring"
alert( str.substring(6, 2) ); // "ring"
```

**Сравнение строк**
- Строчные буквы больше заглавных:
```js
alert( 'a' > 'Z' ); // true
```
- Буквы, имеющие диакритические знаки, идут «не по порядку»:
```js
alert( 'Österreich' > 'Zealand' ); // true
```

Строки кодируются в UTF-16. Таким образом, у любого символа есть соответствующий код
- Символы сравниваются по их кодам. Больший код — больший символ
```js
//String.fromCodePoint(cod
alert( String.fromCodePoint(90) ); // Z
```

Вызов str.localeCompare(str2) возвращает число, которое показывает, какая строка больше в соответствии с правилами языка
```js
alert( 'Österreich'.localeCompare('Zealand') ); // 
```
**полезные метод**
Строки также имеют ещё кое-какие полезные методы:
- str.trim() — убирает пробелы в начале и конце строки.
- str.repeat(n) — повторяет строку n раз.
- …и другие, которые вы можете найти в справочнике

### Массивы

Для хранения упорядоченных коллекций существует особая структура данных, которая называется массив, Array.
- В массиве могут храниться элементы любого типа
**Объявление**

```js
let arr = new Array();
let arr = [];

//Элементы массива нумеруются, начиная с нуля
let fruits = ["Яблоко", "Апельсин", "Слива"];
alert( fruits[0] ); // Яблоко

//добавить новый
fruits[3] = 'Лимон';

//заменить элемент
fruits[2] = 'Груша';

//Общее число элементов
fruits.length ; // 3

//Список элементов массива, как и список свойств объекта, может оканчиваться запятой
let fruits = [
  "Яблоко",
  "Апельсин",
  "Слива",
];
```

**Получение последних элементов при помощи «at»**

```js
let fruits = ["Apple", "Orange", "Plum"];
alert( fruits[fruits.length-1] ); // Plum
alert( fruits.at(-1) ); // Plum
```

**Методы pop/push, shift/unshift**
Массивы в JavaScript могут работать и как очередь, и как стек

Очередь – один из самых распространённых вариантов применения массива.
- push добавляет элемент в конец.
- shift удаляет элемент в начале

Существует и другой вариант применения для массивов – структура данных, называемая стек
- push добавляет элемент в конец.
- pop удаляет последний элемент.

**Методы, работающие с концом массива:**

```js
let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.pop() ); // удаляем "Груша" и выводим его
alert( fruits ); // Яблоко, Апельсин

let fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша");
alert( fruits ); // Яблоко, Апельсин, Груша
```

**Методы, работающие с началом массива:**

```js
let fruits = ["Яблоко", "Апельсин", "Груша"];
alert( fruits.shift() ); // удаляем Яблоко и выводим его
alert( fruits ); // Апельсин, Груша

let fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert( fruits ); // Яблоко, Апельсин, Груша
```

Методы push и unshift могут добавлять сразу несколько элементов

**Внутреннее устройство массива**

- Массив – это особый подвид объектов
- где в роли obj у нас arr, а в качестве ключа – числовой индекс
- Массив является объектом и, следовательно, ведёт себя как объект (копируется по ссылке)
- Движок JavaScript старается хранить элементы массива в непрерывной области памяти, один за другим, так, как это показано на иллюстрациях к этой главе

Варианты неправильного применения массива:
- Добавление нечислового свойства, например: arr.test = 5.
- Создание «дыр», например: добавление arr[0], затем arr[1000] (между ними ничего нет).
- Заполнение массива в обратном порядке, например: arr[1000], arr[999] и т.д.

**Эффективность**
- Методы push/pop выполняются быстро, а методы shift/unshift – медленно.

Операция shift должна выполнить 3 действия(То же самое происходит с unshif):
- Удалить элемент с индексом 0.
- Сдвинуть все элементы влево, заново пронумеровать их, заменив 1 на 0, 2 на 1 и т.д.
- Обновить свойство length .
- Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью.

Методы push/pop не требует перемещения, потому что остальные элементы остаются с теми же индексами. 

**Перебор элементов**
```js
let arr = ["Яблоко", "Апельсин", "Груша"];
for (let i = 0; i < arr.length; i++) {
  alert( arr[i] );
}

//for..of
for (let fruit of fruits) {
  alert( fruit );
}

//Технически, так как массив является объектом, можно использовать и вариант for..in,не следует использовать
//! for..in оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее
//выведит «лишние» свойства
let arr = ["Яблоко", "Апельсин", "Груша"];
for (let key in arr) {
  alert( arr[key] ); // Яблоко, Апельсин, Груша
}
```

**Немного о «length»**
- Свойство length автоматически обновляется при изменении массив
- length – его можно перезаписать, простой способ очистить массив – это arr.length = 0
```js
let fruits = [];
fruits[123] = "Яблоко";
alert( fruits.length ); // 124
```

**new Array()**
- создаёт массив без элементов, но с заданной длиной
```js
let arr = new Array(2); // создастся ли массив [2]?
alert( arr[0] ); // undefined! нет элементов.
alert( arr.length ); // length 2
```

**Многомерные массивы**

```js
let matrix = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
alert( matrix[1][1] ); // 5, центральный элемент
```

**toString**
- Массивы не имеют ни Symbol.toPrimitive, ни функционирующего valueOf, они реализуют только преобразование toString
```js
alert( [1] + 1 ); // "11"
alert( [1,2] + 1 ); // "1,21"
```

**Не сравнивайте массивы при помощи ==**
- Два объекта равны друг другу == только в том случае, если они ссылаются на один и тот же объек
- Если один из аргументов == является объектом, а другой – примитивом, то объект преобразуется в примитив
- не используйте оператор ==. Вместо этого сравните их по элементам в цикле или используя методы итерации
```js
alert( [] == [] ); // false

// после того, как [] был преобразован в ''
alert( 0 == '' ); // true, так как '' преобразуется в число 0
```

### Методы массивов

- arr.push(...items) – добавляет элементы в конец,
- arr.pop() – извлекает элемент из конца,
- arr.shift() – извлекает элемент из начала,
- arr.unshift(...items) – добавляет элементы в начало.

**splice**

- Элемент был удалён, но в массиве всё ещё три элемента
```js
let arr = ["I", "go", "home"];
delete arr[1]; // удалить "go"
alert( arr[1] ); // undefined
// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```

- Поэтому нужно использовать специальные методы
- Метод arr.splice – это универсальный «швейцарский нож» для работы с массивами. Умеет всё: добавлять, удалять и заменять элементы
- Отрицательные индексы разрешены
- Он изменяет arr

```js
let arr = ["Я", "изучаю", "JavaScript"];
arr.splice(1, 1); // начиная с индекса 1, удалить 1 элемент

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");
alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]

let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];
// удалить 2 первых элемента
let removed = arr.splice(0, 2);

//__может вставлять элементы
let arr = ["Я", "изучаю", "JavaScript"];
// с индекса 2
// удалить 0 элементов
// вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert( arr ); // "Я", "изучаю", "сложный", "язык", "JavaScript"
```

**slice**
- возвращает новый массив

```js
let arr = ["t", "e", "s", "t"];
alert( arr.slice(1, 3) ); // e,s (копирует с 1 до 3)
```

**concat**
- создаёт новый массив, в который копирует данные из других массивов 

```js
// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6

//__если объект имеет специальное свойство Symbol.isConcatSpreadable
let arr = [1, 2];
let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};
alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```

**Перебор: forEach**

- запускать функцию для каждого элемента массива
- Результат функции (если она что-то возвращает) отбрасывается и игнорируется.

```js
["Бильбо", "Гэндальф", "Назгул"].forEach((item, index, array) => {
  alert(`У ${item} индекс ${index} в ${array}`);
});
```

**Поиск в массиве**

- indexOf/lastIndexOf и includes

```js
let arr = [1, 0, false];
alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2

//Метод arr.lastIndexOf похож на indexOf, но ищет справа налево.

//Метод includes правильно обрабатывает NaN
const arr = [NaN];
alert( arr.indexOf(NaN) ); // -1 (неверно, должен быть 0)
alert( arr.includes(NaN) );// true (верно)
```

**find и findIndex/findLastIndex**

```js
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
```

**filter**

```js
let results = arr.filter(function(item, index, array) {
  // если `true` -- элемент добавляется к results и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
```

**Преобразование массива**

- возвращает массив

```js
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```

**sort(fn)**

- По умолчанию элементы сортируются как строки
- собственный порядок сортировки, нам нужно предоставить функцию
- функции сравнения требуется любое положительное число, чтобы сказать «больше», и отрицательное число, чтобы сказать «меньше».
- Используйте localeCompare для строк
```js
function compare(a, b) {
  if (a > b) return 1; // если первое значение больше второго
  if (a == b) return 0; // если равны
  if (a < b) return -1; // если первое значение меньше второго
}

let arr = [ 1, 2, 15 ];
arr.sort(compareNumeric);
alert(arr);  // 1, 2, 15

alert( countries.sort( (a, b) => a.localeCompare(b) ) );
```

**reverse**

```js
let arr = [1, 2, 3, 4, 5];
arr.reverse();
alert( arr ); // 5,4,3,2,1
```

**split и join**
- split разбивает строку на массив,второй числовой аргумент – ограничение на количество элементов
- join - объединить в массив
```js
let arr = 'Вася, Петя, Маша, Саша'.split(', ', 2);
alert(arr); // Вася, Петя

let arr = ['Вася', 'Петя', 'Маша'];
let str = arr.join(';'); // объединить массив в строку через ;
alert( str ); // Вася;Петя;Маша
```

**reduce/reduceRight**

-  Они используются для вычисления единого значения на основе всего массива.
- при отсутствии initial в качестве первого значения берётся первый элемент массива,рекомендуется всегда указывать начальное значение
```js
let value = arr.reduce(function(accumulator, item, index, array) {
  // ...
}, [initial])

let arr = [1, 2, 3, 4, 5];
let result = arr.reduce((sum, current) => sum + current, 0);
alert(result); // 15
```

**Array.isArray**
- typeof не может отличить простой объект от массива
- придумали специальный метод
```js
alert(Array.isArray([])); // true
```

**Большинство методов поддерживают «thisArg»**
- Почти все методы массива, которые вызывают функции – такие как find, filter, map, за исключением метода sort, принимают необязательный параметр thisArg
- Значение параметра thisArg становится this для func
```js
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// найти пользователей, для которых army.canJoin возвращает true
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```

**arr.some(fn)/arr.every(fn)**
- Мы можем использовать every для сравнения массивов
```js
function arraysEqual(arr1, arr2) {
  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);
}
alert( arraysEqual([1, 2], [1, 2])); // true
```

**Полный список есть в справочнике MDN.**

### Перебираемые объекты

**Symbol.iterator**

- сделать итерируемым

```js
let range = {
  from: 1,
  to: 5
};

// 1. вызов for..of сначала вызывает эту функцию
range[Symbol.iterator] = function() {

  // ...она возвращает объект итератора:
  // 2. Далее, for..of работает только с этим итератором,
  // запрашивая у него новые значения
  return {
    current: this.from,
    last: this.to,

    // 3. next() вызывается на каждой итерации цикла for..of
    next() {
      // 4. он должен вернуть значение в виде объекта {done:.., value :...}
      if (this.current <= this.last) {
        return { done: false, value: this.current++ };
      } else {
        return { done: true };
      }
    }
  };
};

// теперь работает!
for (let num of range) {
  alert(num); // 1, затем 2, 3, 4, 5
}
```

Можно сделать бесконечный итератор. Например, range будет бесконечным при range.to = Infinity

**Строка – перебираемый объект**

```js
for (let char of "test") {
  // срабатывает 4 раза: по одному для каждого символа
  alert( char ); // t, затем e, затем s, затем t
}
```

**Явный вызов итератора**

```js
let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
```

**Итерируемые объекты и псевдомассивы**
- Итерируемые объекты – это объекты, которые реализуют метод Symbol.iterator, как было описано выше.
- Псевдомассивы – это объекты, у которых есть индексы и свойство length, то есть, они выглядят как массивы
- При использовании JavaScript в браузере или других окружениях мы можем встретить объекты, которые являются итерируемыми или псевдомассивами, или и тем, и другим.
```js
let arrayLike = { // есть индексы и свойство length => псевдомассив
  0: "Hello",
  1: "World",
  length: 2
};

// Ошибка (отсутствует Symbol.iterator)
for (let item of arrayLike) {}
```

**Array.from**

- принимает итерируемый объект или псевдомассив и делает из него «настоящий» Array

```js
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};
let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
```

Необязательный второй аргумент может быть функцией
```js
let arr = Array.from(range, num => num * num);
alert(arr); // 1,4,9,16,25
```

### Map и Set

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа.

Методы и свойства:
- new Map() – создаёт коллекцию.
- map.set(key, value) – записывает по ключу key значение value.
- map.get(key) – возвращает значение по ключу или undefined, если ключ key отсутствует.
- map.has(key) – возвращает true, если ключ key присутствует в коллекции, иначе false.
- map.delete(key) – удаляет элемент (пару «ключ/значение») по ключу key.
- map.clear() – очищает коллекцию от всех элементов.
- map.size – возвращает текущее количество элементов.

```js
let map = new Map();
map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ
// помните, обычный объект Object приводит ключи к строкам?
// Map сохраняет тип ключей, так что в этом случае сохранится 2 разных значения:
alert(map.get(1)); // "num1"
alert(map.get("1")); // "str1
alert(map.size); // 3
```

**Map может использовать объекты в качестве ключей.**

- но мы не можем использовать другой Object в качестве ключа

```js
let john = { name: "John" };
// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();
// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);
alert(visitsCountMap.get(john)); // 123
```

**Цепочка вызовов**

```js
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
```

**Перебор Map**
- map.keys() – возвращает итерируемый объект по ключам,
- map.values() – возвращает итерируемый объект по значениям,
- map.entries() – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется по умолчанию в for..of.
```js
let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

// перебор по ключам (овощи)
for (let vegetable of recipeMap.keys()) {
  alert(vegetable); // огурец, помидор, лук
}

// перебор по значениям (числа)
for (let amount of recipeMap.values()) {
  alert(amount); // 500, 350, 50
}

// перебор по элементам в формате [ключ, значение]
for (let entry of recipeMap) { // то же самое, что и recipeMap.entries()
  alert(entry); // огурец,500 (и так далее)
}
```

В отличие от обычных объектов Object, в Map перебор происходит в том же порядке, в каком происходило добавление элементов.


**Object.entries: Map из Object**

- есть обычный объект, и мы хотели бы создать Map

```js
let obj = {
  name: "John",
  age: 30
};
let map = new Map(Object.entries(obj));
alert( map.get('name') ); // John
```

**Object.fromEntries: Object из Map**

- создаёт из них объект
```js
let prices = Object.fromEntries([
  ['banana', 1],
  ['orange', 2],
  ['meat', 4]
]);
// prices = { banana: 1, orange: 2, meat: 4 }
alert(prices.orange); // 2
```

**Set**

- каждое значение может появляться только один раз

- new Set(iterable) – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его значения в новый Set.
- set.add(value) – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
- set.delete(value) – удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
- set.has(value) – возвращает true, если значение присутствует в множестве, иначе false.
- set.clear() – удаляет все имеющиеся значения.
- set.size – возвращает количество элементов в множестве.

```js
let set = new Set();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

// считаем гостей, некоторые приходят несколько раз
set.add(john);
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

// set хранит только 3 уникальных значения
alert(set.size); // 3

for (let user of set) {
  alert(user.name); // John (потом Pete и Mary)
}
```

**Перебор объекта Set**

```js
let set = new Set(["апельсин", "яблоко", "банан"]);

for (let value of set) alert(value);

// то же самое с forEach:
set.forEach((value, valueAgain, set) => {
  alert(value);
});
```

### WeakMap и WeakSet

- не поддерживает перебор и методы keys(), values(), entries()

-  WeakMap должны быть объектами, а не примитивными значениями

```js
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok"); // работает (объект в качестве ключа)
```

- если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

```js
let john = { name: "John" };
let weakMap = new WeakMap();
weakMap.set(john, "...");
john = null; // перезаписываем ссылку на объект
// объект john удалён из памяти! используеться в качестве объекта
```

WeakMap используется в качестве дополнительного хранилища данных

Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти, ассоциированные с ними данные тоже автоматически исчезнут.
```js
weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены
```

**Применение для кеширования**

- использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора

```js
// 📁 cache.js
let cache = new WeakMap();

// вычисляем и запоминаем результат
function process(obj) {
  if (!cache.has(obj)) {
    let result = /* вычисляем результат для объекта */ obj;

    cache.set(obj, result);
  }

  return cache.get(obj);
}

// 📁 main.js
let obj = {/* какой-то объект */};

let result1 = process(obj);
let result2 = process(obj);

// ...позже, когда объект больше не нужен:
obj = null;

// Нет возможности получить cache.size, так как это WeakMap,
// но он равен 0 или скоро будет равен 0
// Когда сборщик мусора удаляет obj, связанные с ним данные из кеша тоже удаляются
```

**WeakSet**

- аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения)

```js
let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

// visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;

// структура данных visitedSet будет очищена автоматически (объект john будет удалён из visitedSet)
```

### Object.keys, values, entries

для структур:
- Map
- Set
- Array

- Object.keys(obj) – возвращает массив ключей.
- Object.values(obj) – возвращает массив значений.
- Object.entries(obj) – возвращает массив пар [ключ, значение].

- гнорируют свойства, использующие Symbol(...) в качестве ключей

**Трансформации объекта**

```js
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};
let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries (обратно в объект)
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
alert(doublePrices.meat); // 8
```

### Деструктурирующее присваивание

- «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача – только скопировать нужные значения в переменные.

```js
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"];
// деструктурирующее присваивание
// записывает firstName = arr[0]
// и surname = arr[1]
let [firstName, surname] = arr;

alert(firstName); // Ilya
alert(surname);  // Kantor
let [firstName, surname] = "Ilya Kantor".split(' ');
alert(firstName); // Ilya
alert(surname);  // Kantor

//Пропускайте элементы, используя запятые
// второй элемент не нужен
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert( title ); // Consul

//Работает с любым перебираемым объектом
let [a, b, c] = "abc";
let [one, two, three] = new Set([1, 2, 3])

//Цикл с .entries()
let user = {
  name: "John",
  age: 30
};

// цикл по ключам и значениям
for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, затем age:30
}
```

**Трюк обмена переменных**

```js
let guest = "Jane";
let admin = "Pete";
// Давайте поменяем местами значения: сделаем guest = "Pete", а admin = "Jane"
[guest, admin] = [admin, guest];
```

**Остаточные параметры «…»**

```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// rest это массив элементов, начиная с 3-го
alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```

**Значения по умолчанию**

```js
// значения по умолчанию
let [name = "Guest", surname = "Anonymous"] = ["Julius"];

alert(name);    // Julius (из массива)
alert(surname); // Anonymous (значение по умолчанию)

// prompt запустится только для surname
let [name = prompt('name?'), surname = prompt('surname?')] = ["Julius"];
```

**Деструктуризация объекта**

- Деструктурирующее присваивание также работает с объектами

```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};
let {title, width, height} = options;
alert(title);  // Menu
alert(width);  // 100
alert(height); // 200

//Порядок не имеет значения
let {height, width, title} = { title: "Menu", height: 200, width: 100 }
```

```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;

// width -> w
// height -> h
// title -> title

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

значения по умолчанию

```js
let options = {
  title: "Menu"
};

let {width = 100, height = 200, title} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
```

совмещать : и =:
```js
let options = {
  title: "Menu"
};

let {width: w = 100, height: h = 200, title} = options;

alert(title);  // Menu
alert(w);      // 100
alert(h);      // 200
```

игнорировать остальное
```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

// взять только title, игнорировать остальное
let { title } = options;

alert(title); // Menu
```

**Остаток объекта «…»**

- В некоторых старых браузерах (IE) это не поддерживается, используйте Babel для полифила.

```js
let options = {
  title: "Menu",
  height: 200,
  width: 100
};

// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;

// сейчас title="Menu", rest={height: 200, width: 100}
alert(rest.height);  // 200
alert(rest.width);   // 100
```

**Вложенная деструктуризация**

```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;

alert(title);  // Menu
alert(width);  // 100
alert(height); // 200
alert(item1);  // Cake
alert(item2);  // Donut
```

**Умные параметры функций**

```js
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};
function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}
showMenu(options);

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}
showMenu(); // Menu 100 200
```

### Дата и время

**Создание**

```js
let now = new Date();
alert( now ); // показывает текущие дату и время


// 0 соответствует 01.01.1970 UTC+0
let Jan01_1970 = new Date(0);
alert( Jan01_1970 );
// теперь добавим 24 часа и получим 02.01.1970 UTC+0
let Jan02_1970 = new Date(24 * 3600 * 1000);
alert( Jan02_1970 );


//Датам до 1 января 1970 будут соответствовать отрицательные таймстампы
let Dec31_1969 = new Date(-24 * 3600 * 1000);
alert( Dec31_1969 );


//Максимальная точность – 1 мс (до 1/1000 секунды):
let date = new Date(2011, 0, 1, 2, 3, 4, 567);
alert( date ); // 1.01.2011, 02:03:04.567
```

**Получение компонентов даты**
- getFullYear() Получить год (4 цифры)
- getMonth() Получить месяц, от 0 до 11.
- getDate() Получить день месяца, от 1 до 31, что несколько противоречит названию метода.
- getHours(), getMinutes(), getSeconds(), getMilliseconds() Получить, соответственно, часы, минуты, секунды или миллисекунды.
- в JavaScript начало недели приходится на воскресенье
- Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом.
- getTime() Для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
- getTimezoneOffset() Возвращает разницу в минутах между UTC и местным часовым поясом:

**Установка компонентов даты**
- setFullYear(year, [month], [date])
- setMonth(month, [date])
- setDate(date)
- setHours(hour, [min], [sec], [ms])
- setMinutes(min, [sec], [ms])
- setSeconds(sec, [ms])
- setMilliseconds(ms)
- setTime(milliseconds)

**Автоисправление даты**

- Неправильные компоненты даты автоматически распределяются по остальным.

```js
let date = new Date(2013, 0, 32); // 32 Jan 2013 ?!?
alert(date); // ...1st Feb 2013!
```

**Преобразование к числу, разность дат**
- Если объект Date преобразовать в число, то получим таймстамп по аналогии с date.getTime
```js
let start = new Date(); // начинаем отсчёт времени

// выполняем некоторые действия
for (let i = 0; i < 100000; i++) {
  let doSomething = i * i * i;
}
let end = new Date(); // заканчиваем отсчёт времени
alert( `Цикл отработал за ${end - start} миллисекунд` )
```

**Date.now()**
- Если нужно просто измерить время, объект Date нам не нужен.
- Существует особый метод Date.now(), возвращающий текущую метку времени.


