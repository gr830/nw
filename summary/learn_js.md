# learn.javascript.ru

## Введение

### Введение в JavaScript

Изначально JavaScript был создан, чтобы «сделать веб-страницы живыми»

Сегодня JavaScript может выполняться не только в браузере, но и на сервере или на любом другом устройстве, которое имеет специальную программу, называющуюся «движком» JavaScript

Движки сложны. Но основы понять легко.
- Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
- Затем он преобразует («компилирует») скрипт в машинный язык.
- После этого машинный код запускается и работает достаточно быстро.

Возможности JavaScript в браузере ограничены ради безопасности пользователя. 
- JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.
- Различные окна/вкладки не знают друг о друге. «Политика одинакового источника».

Как минимум, три сильные стороны JavaScript:
- Полная интеграция с HTML/CSS.
- Простые вещи делаются просто.
- Поддерживается всеми основными браузерами и включён по умолчанию.

### Справочники и спецификации

Спецификация ECMA содержит самую глубокую, детальную и формализованную информацию о JavaScript

MDN (Mozilla) JavaScript Reference – это справочник с примерами и другой информацией. Хороший источник для получения подробных сведений о функциях языка, методах встроенных объектов и так далее.

Таблицы совместимости - https://caniuse.com – таблицы с информацией о поддержке 

### Редакторы кода

Термином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.

### Консоль разработчика

Но по умолчанию в браузере ошибки не видны.
Для решения задач такого рода в браузер встроены так называемые «Инструменты разработки».

Нажмите F12

## Основы JavaScript

### Привет, мир!

Для серверных сред (например, Node.js), вы можете выполнить скрипт с помощью команды типа "node my.js"

Тег «script»
```html
 <script>
    alert( 'Привет, мир!' );
 </script>

<!-- Внешние скрипты  -->
<script src="/path/to/script.js"></script>
```
- /path/to/script.js – это абсолютный путь от корневой папки
- можно указать относительный путь от текущей страницы. Например, src="script.js"

### Структура кода

- Инструкции – это синтаксические конструкции и команды, которые выполняют действия
- Инструкции могут отделяться точкой с запятой
- В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку
- В некоторых ситуациях новая строка всё же не означает точку с запятой
```js
alert(3 +
1
+ 2);

//будет ошибка
alert('Hello')
[1, 2].forEach(alert);
//alert('Hello')[1, 2].forEach(alert);
```
- Мы рекомендуем ставить точку с запятой между инструкциями, даже если они отделены переносами строк

**Комментарии**
- Ctrl+/ для однострочного комментария 
- Ctrl+Shift+/ – для многострочных комментариев
- Вложенные комментарии не поддерживаются! Не может быть /*...*/ внутри /*...*/.
```js
// Этот комментарий занимает всю строку
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
```

### Строгий режим — "use strict"

- Убедитесь, что «use strict» находится в начале
- Нет никакого способа отменить use strict
- Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать, они автоматически включают строгий режим
```js
"use strict";
// этот код работает в современном режиме
```

```js
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке
"use strict";
```

### Переменные

Переменная – это «именованное хранилище» для данных. 

```js
let message;
message = 'Hello!';
alert(message); // показывает содержимое переменной

//можем объявить несколько переменных в одной строке
let user = 'John', age = 25, message = 'Hello';

//____
//можем объявить две переменные и скопировать данные из одной в другую
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!

//_____
//Повторное объявление вызывает ошибку
let message = "Это";
let message = "Другое"; // SyntaxError: 'message'

//____
//Это плохая практика, которая приводит к ошибке в строгом режиме:
"use strict";
num = 5; // ошибка: num is not defined
```

**Имена переменных**
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.
- обычно используется верблюжья нотация - myVeryLongName
- дефис '-' не разрешён в имени
- Регистр имеет значение
- Нелатинские буквы разрешены, но не рекомендуются
- Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

**Константы**

- Их нельзя изменить. Попытка сделать это приведёт к ошибке
```js
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!

//____
//Константы в верхнем регистре - константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений
const COLOR_RED = "#F00";
```

**Придумывайте правильные имена**

- ясный и понятный смысл
- говорить о том, какие данные в ней хранятся

**Итого**

- let – это современный способ объявления.
- var – это устаревший способ объявления
- const – похоже на let, но значение переменной не может изменяться.

### Типы данных

Есть восемь основных типов данных в JavaScript

**Число**

- представляет как целочисленные значения, так и числа с плавающей точкой
- cуществует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание -
-  существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

```js
let n = 123;
n = 12.345;
alert( 1 / 0 ); // Infinity

//NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
//Любая математическая операция с NaN возвращает NaN
"не число" / 2 // NaN
alert( NaN + 1 ); 
```

**BigInt**

- все нечетные целые числа, большие чем (253-1), вообще не могут храниться в типе number
- необходимо добавить n в конец

```js
const bigInt = 1234567890123456789012345678901234567890n;
```

**Строка**

```js
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
//Обратные же кавычки имеют расширенную функциональность
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
```

**Булевый (логический) тип**

- true (истина) и false (ложь).

```js
let isGreater = 4 > 1;// true (результатом сравнения будет "да")
```

**Значение «null»**

- представляет собой «ничего», «пусто» или «значение неизвестно».
```js
let age = null;
```

**Значение «undefined»**
- сли переменная объявлена, но ей не присвоено никакого значения
```js
let age;
alert(age); // выведет "undefined"
```

**Объекты и символы**

Тип object (объект) – особенный.
- Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

**Тип symbol**

Используется для создания уникальных идентификаторов в объекта.

**Оператор typeof**

```js
// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже),скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения
typeof(5) // Также выведет "number

typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1) / Math — это встроенный объект
typeof null // "object"  (2) / Это официально признанная ошибка в typeof
typeof alert // "function"  (3) / alert является функцие / Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function"
```

### Взаимодействие: alert, prompt, confirm

- alert- она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК»
```js
alert("Hello");
```
- prompt - отобразит модальное окно с текстом,default
необязательный второй параметр, который устанавливает начальное значен
```js
let age = prompt('Сколько тебе лет?', 100);
```
- confirm - функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
```js
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK
```

### Преобразование типов

**Строковое преобразование**
```js
let value = true;
value = String(value); // теперь value это строка "true
```

**Численное преобразование**

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.

```js
alert( "6" / "2" ); // 3, строки преобразуются в числа

//явно преобразовать value
let str = "123";
let num = Number(str); // становится числом 1
```

- undefined - NaN
- null - 0
- true / false	1 /  - 0
- string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

**Логическое преобразование**

Правило преобразования:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
- Все остальные значения становятся true
```js
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
```

### Базовые операторы, математика

**Термины: «унарный», «бинарный», «операнд»**

Операнд – то, к чему применяется оператор. 

Унарным называется оператор, который применяется к одному операнду
```js
let x = 1;
x = -x;
```

Бинарным называется оператор, который применяется к двум операндам
```js
y - x
```

**Математика**

- Сложение +,
- Вычитание -,
- Умножение *,
- Деление /,
- Взятие остатка от деления %,
- Возведение в степень **

```js
5 % 2 ; // 1, остаток от деления 5 на 2
2 ** 2 ; // 2² = 4
 4 ** (1/2) ; // 2 (степень 1/2 эквивалентна взятию квадратного корня)
```

### Сложение строк при помощи бинарного +

```js
let s = "моя" + "строка"; // моястрока
'1' + 2 ; // "12"
2 + 2 + '1' ; // будет "41", а не "221"
```

Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
```js
6 - '2' ; // 4, '2'
```

**Приведение к числу, унарный +**

- Если операнд не число, унарный плюс преобразует его в число.
```js
+true ; // 1

let apples = "2";
let oranges = "3";
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
```

**Приоритет операторов**

В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

**Присваивание**

Один из самых низких приоритетов: 2
```js
let x = 2 * 2 + 1; // 5
```

Присваивание = возвращает значение
```js
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
```

Присваивание по цепочке
```js
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Сокращённая арифметика с присваиванием
```js
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 
```

**Инкремент/декремент**

Инкремент ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
```

Декремент -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
```

Операторы ++ и -- могут быть расположены не только после, но и до переменной.
- Когда оператор идёт после переменной — это «постфиксная форма»: counter++,постфиксная форма возвращает старое (до увеличения/уменьшения числа)
```js
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++
alert(a); // 1
```
- «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
```js
let counter = 1;
let a = ++counter; // (*)
alert(a); // 2
```

Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать.Если хочется тут же использовать результат, то нужна префиксная форма.

Операторы ++/-- могут также использоваться внутри выражений.
```js
let counter = 1;
alert( 2 * ++counter ); 
```

**Побитовые операторы**

Побитовые операторы работают с 32-разрядными целыми числами
- AND(и) ( & )
- OR(или) ( | )
- XOR(побитовое исключающее или) ( ^ )
- NOT(не) ( ~ )
- LEFT SHIFT(левый сдвиг) ( << )
- RIGHT SHIFT(правый сдвиг) ( >> )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

**Оператор «запятая»**

- написания более короткого кода
- но возвращается результат только последнего
```js
let a = (1 + 2, 3 + 4);// 7 (результат вычисления 3 + 4)

//Запятая имеет очень низкий приоритет,ниже =
a = 1 + 2, 3 + 4;
alert(a); // 3 

// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {}
```

### Операторы сравнения

**Результат сравнения имеет логический тип**

- true – означает «да», «верно», «истина».
- false – означает «нет», «неверно», «ложь

```js
2 > 1 ;  // true
```

**Сравнение строк**

- строки сравниваются посимвольно
- К равна К.
- о равна о.
- т больше, чем д. На этом сравнение заканчивается. Первая строка больше.
```js
'Я' > 'А' ; // true
'Коты' > 'Кода' ; // true
```

**Сравнение разных типов**

- При сравнении значений разных типов JavaScript приводит каждое из них к числу.

```js
'2' > 1 ; // true, строка '2' становится числом 2
'01' == 1 ; // true, строка '01' становится числом 1

let a = 0;
Boolean(a); // false
let b = "0";
Boolean(b); // true
a == b; // true
```

**Строгое сравнение**

Оператор строгого равенства === проверяет равенство без приведения типов.
```js
0 == false ; // true
0 === false ; // false, так как сравниваются разные типы
```

**Сравнение с null и undefined**

Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

```js
null === undefined ; // false

null == 0 ; // (2) false
//Сравнения преобразуют null в число
alert( null >= 0 ); // (3) true
```

Значение undefined несравнимо с другими значениями:
- undefined преобразуется в NaN
```js
undefined > 0 ; // false (1)
```

**Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.**

### Условное ветвление: if, '?'

**Инструкция «if»**

Инструкция if(...) вычисляет условие в скобках и, если результат true

```js
if (year == 2015) alert( 'Вы правы!' );

if (year == 2015) {
   //...
}
```

**Преобразование к логическому типу**

- if (…) вычисляет выражение в скобках и преобразует результат к логическому типу
- Инструкция if может содержать необязательный блок «else» («иначе»)
- Иногда нужно проверить несколько вариантов условия. Для этого используется блок else if

```js
let year = 2013
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

**Условный оператор „?“**

- Его также называют тернарный

```js
let accessAllowed = (age > 18) ? true : false;
```

**Несколько операторов „?“**

```js
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
```

### Логические операторы

- || (ИЛИ)
- && (И) 
- ! (НЕ)
- ?? (Оператор нулевого слияния)

**|| (ИЛИ)**

-  в случае, если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается fals

```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

**ИЛИ "||" находит первое истинное значение**

- цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

```js
undefined || null || 0 ; // 0 (поскольку все ложно, возвращается последнее значение)

//Если бы все переменные были ложными, в качестве результата мы бы наблюдали "Аноним".
let firstName = "";
let lastName = "";
let nickName = "Суперкодер";
alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```

**||= (Логическое присваивание ИЛИ)**

- Если a ложно, присваивает a значение b
```js
a || (a = b);

//__
let johnHasCar = false;
johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")
alert( johnHasCar ); // "У Джона нет машины!"

//можем переписать приведённые выше примеры с использованием обычного if
let johnHasCar = false;
if (johnHasCar == false) {
  johnHasCar = "У Джона нет машины!";
}
alert(johnHasCar); // "У Джона нет машины!"
```

**&& (И)**

```js
//В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Оператор && выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. - Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

```js
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3
```

Несмотря на то, что вариант с && кажется более коротким, if более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать if, если нам нужно if, и использовать &&, если нам нужно И.

**&&= (Логическое присваивание И)**

&&= присвоит a значение b только в том случае, если a истинно.

```js
a &&= b; //a && (a = b);
```

**! (НЕ)**

- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.

```js
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ !! используют для преобразования значений к логическому типу:
```js
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```

### Операторы нулевого слияния и присваивания: '??', '??='

- оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.


Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.
```js
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
```

Приоритет оператора ?? такой же, как и у ||. Они оба равны 3 в таблице на MDN.

По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

Можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```

**Оператор нулевого присваивания (??=)**

??= присвоит x значение y только в том случае, если x не определено (null/undefined).
```js
let userAge = null;
userAge ??= 18;
alert(userAge) // 18
```

### Циклы while и for

**Цикл «while»**

- Код из тела цикла выполняется, пока условие condition истинно
- условие while вычисляется и преобразуется в логическое значение
```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки
```js
while (i) alert(i--);
```

**Цикл «do…while»**

Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

**Цикл «for»**
- начало	let i = 0	Выполняется один раз при входе в цикл
- условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
- тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
- шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
```js
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

**Пропуск частей «for»**

```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

//__
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
//Это сделает цикл аналогичным while (i < 3).
```

**Прерывание цикла: «break»**

Полностью прекращает выполнение цикла

```js
let sum = 0;

while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );
```

**Переход к следующей итерации: continue**

При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

```js
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

**Нельзя использовать break/continue справа от оператора „?“**

синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?
```js
(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
```

**Метки для break/continue**

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

```js
// outer:
// for (let i = 0; i < 3; i++) { ... }
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    //// не прыгает к метке ниже
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}
```

### Конструкция "switch"

Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

```js
switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

//Любое выражение может быть аргументом
switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}
```

**Группировка «case»**

```js
switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
```

**Тип имеет значение**

Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

### Функции

- Повторять одно и то же действие во многих частях программы.
- Одно из главных предназначений функций: избавление от дублирования кода.

**Объявление функции**

```js
function имя(параметры) {
  //...тело...
}
```

**Локальные переменные**

Переменные, объявленные внутри функции, видны только внутри этой функции
```js
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная
  alert( message );
}
showMessage(); // Привет, я JavaScript!
alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции
```

**Внешние переменные**

У функции есть доступ к внешним переменным

Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

```js
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // Привет, Вася
```

**Параметры**

- Функция всегда получает только копию значения
- Параметр – это переменная, указанная в круглых скобках в объявлении функции.
- Аргумент – это значение, которое передаётся функции при её вызове.
```js
function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}
```

**Значения по умолчанию**

```js
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}

//параметров по умолчанию в ранних версиях JavaScript
function showMessage(from, text) {
  if (text === undefined) {
    text = 'текст не добавлен';
  }
}

function showMessage(from, text) {
  text = text || 'текст не добавлен';
}
```

**Возврат значения**

Функция может вернуть результат

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код

```js
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2); // 3

function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

//Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции
//Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;//undefined
  }
}

//Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

**Bыбор имени функции**

Функция – это действие. Поэтому имя функции обычно является глаголом
Функции, начинающиеся с…
- "get…" – возвращают значение,
- "calc…" – что-то вычисляют,
- "create…" – что-то создают,
- "check…" – что-то проверяют и возвращают логическое значение, и т.д.

**Одна функция – одно действие**

Функции должны быть короткими и делать только что-то одно.

### Function Expression

Функциональное Выражение
- создать функцию и поместить её в переменную

```js
let sayHi = function() {
  alert( "Привет" );
};
```

**Функция – это значение**

```js
function sayHi() {
  alert( "Привет" );
}
alert( sayHi ); // выведет код функции

//Мы можем скопировать функцию в другую переменную
let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет 

//выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi
```

**Функции-«колбэки»**

Аргументы showOk и showCancel функции ask называются функциями-колбэками или просто колбэками.

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "Вы согласны." );
}
function showCancel() {
  alert( "Вы отменили выполнение." );
}
// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

//__
//Здесь функции объявляются прямо внутри вызова ask(...). У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи ask
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```

**Function Expression в сравнении с Function Declaration**

- Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
- Function Declaration может быть вызвана раньше, чем она объявлена.
- Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них.

```js
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```

В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
```js
//Function Declaration видимо только внутри блока код
if (age < 18) {
  function welcome() {
    alert("Привет!");
  }
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}
// ...не работает
welcome(); // Error: welcome is not defined

//___Верным подходом будет объявленние снаружи
let welcome;
if (age < 18) {
  welcome = function() {
    alert("Привет!");
  };
} else {
  welcome = function() {
    alert("Здравствуйте!");
  };
}
welcome(); 
```

### Стрелочные функции, основы

```js
let sum = (a, b) => a + b;

//Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить
let double = n => n * 2;
```

**Многострочные стрелочные функции**

```js
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};
```

## Качество кода

### Отладка в браузере

Отладка – это процесс поиска и исправления ошибок в скрипте. 

**Панель «Исходный код» («Sources»)**

- В зоне File Navigator (панель для навигации файлов) 
- Зона Code Editor
- зона JavaScript Debuggin

**Точки останова (breakpoints)**
- Точка останова – это участок кода, где отладчик автоматически приостановит исполнение JavaScript
- щёлкните на номере строки, вы поставили точку останова
- Пока исполнение поставлено «на паузу», мы можем просмотреть текущие значения переменных

**Команда debugger**

```js
function hello(name) {
  let phrase = `Привет, ${name}!`;
  debugger;  // <-- тут отладчик остановится
  say(phrase);
}
```

**Остановимся и оглядимся**

- Для начала отладки (после того, как мы поставили точки останова) проще всего её перезагрузить
- Watch– показывает текущие значения для любых выражений
- Call Stack – показывает цепочку вложенных вызовов
- Scope показывает текущие переменные
- В Global перечисляются глобальные переменные

**Пошаговое выполнение скрипта**

-  –> «Resume»: продолжить выполнение, быстрая клавиша F8.Выполнение кода возобновилось, дошло до другой точки останова
- «Step»: выполнить следующую команду, быстрая клавиша F9.Выполняет следующую инструкцию,«Step» игнорирует асинхронные действия
- «Step over»: выполнить следующую команду, но не заходя внутрь функции, быстрая клавиша F10, выполняет вызов вложенной функции незаметно для нас, пропуская её внутренний код.
- «Step into», быстрая клавиша F11.«Step into» входит в их код, ожидая асинхронные действия
- «Step out»: продолжить выполнение до завершения текущей функции, быстрая клавиша Shift+F11.Продолжает выполнение и останавливает его в самой последней строке текущей функции.
- активировать/деактивировать все точки останова(breakpoints).
- включить/отключить автоматическую паузу в случае ошибки.

**Логирование**

Чтобы вывести что-то на консоль из нашего кода, существует функция console.log.
```js
console.log("value,", i);
```

### Советы по стилю кода

**Синтаксис**

```js
//_Фигурные скобки
if (n < 0) {
  alert(`Степень ${n} не поддерживается`);
}

```

**Длина строки**

Максимальную длину строки согласовывают в команде. Обычно это 80 или 120 символов

**Отступы**

- Горизонтальные отступы: 2 или 4 пробела.
- Вертикальные отступы: пустые строки для разбивки кода на «логические блоки».
```js
function pow(x, n) {
  let result = 1;
  //              <--
  for (let i = 0; i < n; i++) {
    result *= x;
  }
  //              <--
  return result;
}
```

**Точка с запятой**

Должны присутствовать после каждого выражения

**Уровни вложенности**

Уровней вложенности должно быть немного.

```js
//вариант является более читабельным, потому что «особый случай» n < 0 обрабатывается на ранней стадии
function pow(x, n) {
  if (n < 0) {
    alert("Отрицательные значения 'n' не поддерживаются");
    return;
  }

  let result = 1;

  for (let i = 0; i < n; i++) {
    result *= x;
  }

  return result;
}
```

**Размещение функций**

```js
//Объявить функции перед кодом, который их вызове
function createElement() {
  //...
}

// код, который использует их
let elem = createElement();
setHandler(elem);
walkAround();
```

Некоторые популярные руководства:
- Google JavaScript Style Guide
- Airbnb JavaScript Style Guide (есть перевод)
- Idiomatic.JS (есть перевод)
- StandardJS
- (и ещё множество других)

**Автоматизированные средства проверки (линтеры)**

Автоматически проверять стиль вашего кода и вносить предложения по его улучшению.

- JSLint – проверяет код на соответствие стилю JSLint
- ESLint – пожалуй, самый современный линтер

### Комментарии

- могут быть однострочными, начинающимися с //, и многострочными: /* ... */
- в хорошем коде количество «объясняющих» комментариев должно быть минимальным
- Функция сама становится комментарием. Такой код называется самодокументированным.
- В целом мы должны стараться писать простой и самодокументированный код

**Хорошие комментарии**

Есть специальный синтаксис JSDoc для документирования функций
```js
/**
 * Возвращает x, возведённое в n-ную степень.
 *
 * @param {number} x Возводимое в степень число.
 * @param {number} n Степень, должна быть натуральным числом.
 * @return {number} x, возведённое в n-ную степень.
 */
function pow(x, n) {
  //...
}
```

### Ниндзя-код

- использовать короткие имена переменных
- Пишите «как короче», а не как понятнее
- Используйте сокращения
- Будьте абстрактны при выборе имени.
- Добавляйте подчёркивания _ и __ к именам переменных. Например, _name или __value,желательно, чтобы их смысл был известен только вам.
- Пусть все видят, какими замечательными сущностями вы оперируете! Имена superElement, megaFrame и niceItem
- Перекрывайте внешние переменные

### Тесты

- При тестировании кода ручными перезапусками легко упустить что-нибудь важное.
- Автоматическое тестирование означает, что тесты пишутся отдельно, в дополнение к коду. Они по-разному запускают наши функции и сравнивают результат с ожидаемым.

**Behavior Driven Development (BDD)**

В BDD сначала пишут спецификацию, а потом реализацию.

Разработка проходит итеративно. Мы пишем спецификацию, реализуем её, проверяем, что тесты выполняются без ошибок, пишем ещё тесты, снова проверяем, что они проходят и т.д.

```js
//__test.js
//Какую функциональность мы описываем
describe("pow", function() {
  
  //описываем конкретный способ использования функции
  it("возводит в степень n", function() {

    //используются для проверки
    assert.equal(pow(2, 3), 8);
  });

});
```

!Один тест проверяет одну вещь.

**вложенные блоки describe**

- Группировка производится вложенными блоками describe
- Вложенные describe образуют новую подгруппу тестов

Мы можем задать before/after функции, которые будут выполняться до/после тестов
```js
describe("тест", function() {
  before(() => alert("Тестирование началось – перед тестами"));
  after(() => alert("Тестирование закончилось – после всех тестов"));
  it('тест 1', () => alert(1));
  it('тест 2', () => alert(2));
});
```

### Полифилы

- Термин «полифил» означает, что скрипт «заполняет» пробелы и добавляет современные функции.

**Babel**

- Babel – это транспилер. Он переписывает современный JavaScript-код в предыдущий стандарт.

Таким образом, чтобы современные функции поддерживались в старых движках, нам надо установить транспилер и добавить полифил.

## Объекты: основы

### Объекты

- {…} с необязательным списком свойств
- Свойство – это пара «ключ: значение», где ключ – это строка

```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта"
```

**Литералы и свойства**

- При использовании литерального синтаксиса {...} мы сразу можем поместить в объект несколько свойств в виде пар «ключ: значение
- Значение может быть любого типа

```js
let user = {   
  name: "John",  
  age: 30    
};

// получаем свойства объекта:
user.name ; // John

//Значение может быть любого типа. Давайте добавим свойство 
user.isAdmin = true;

//удаления свойства
delete user.age;
```

Cвойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки
```js
let user = {
  "likes birds": true  
};
```

Объект, объявленный через const, может быть изменён
- const защищает от изменений только саму переменную user, а не её содержимое.
```js
const user = {
  name: "John"
};
user.name = "Pete"; // (*)
alert(user.name); // Pete
```

**Квадратные скобки**

Для свойств, имена которых состоят из нескольких слов, доступ к значению «через точку» не работает.Для таких случаев существует альтернативный способ.
```js
let user = {};
user["likes birds"] = true;
alert(user["likes birds"]); // true
```

Квадратные скобки также позволяют обратиться к свойству, имя которого может быть результатом выражения
```js
let key = "likes birds";
user[key] = true;
```

**Вычисляемые свойства**

```js
let fruit = prompt("Какой фрукт купить?", "apple");
let bag = {
  [fruit]: 5, 
};
alert( bag.apple ); // 5, если fruit="apple"

//более сложные выражения
let fruit = 'apple';
let bag = {
  [fruit + 'Computers']: 5 // bag.appleComputers = 5
};
```

**Свойство из переменной**

```js
function makeUser(name, age) {
  return {
    name, // то же самое, что и name: name
    age   // то же самое, что и age: age
    // ...
  };
}
```

**Ограничения на имена свойств**

- нет никаких ограничений к именам свойств
- Есть небольшой подводный камень, связанный со специальным свойством proto Мы не можем установить его в необъектное значение

**Проверка существования свойства, оператор «in»**

```js
let user = { name: "John", age: 30 };
alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует

//В большинстве случаев прекрасно сработает сравнение с undefined. Но есть особый случай, когда оно не подходит и нужно использовать "in".
let obj = {
  test: undefined
};
alert( obj.test ); //  выведет undefined, значит свойство не существует?
alert( "test" in obj ); // true, свойство существует!
```

**Цикл "for..in"**

```js
let user = {
  name: "John",
  age: 30,
  isAdmin: true
};
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```

**Упорядочение свойств объекта**

Упорядочены особым образом: свойства с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.То есть, "49" – это целочисленное имя свойства, потому что если его преобразовать в целое число, а затем обратно в строку, то оно не изменится. А вот свойства "+49" или "1.2" таковыми не являются.Если ключи не целочисленные, то они перебираются в порядке создания
```js
let codes = {
  "+49": "Германия",
  "+41": "Швейцария",
  "+44": "Великобритания",
  // ..,
  "+1": "США"
};
for (let code in codes) {
  alert( +code ); // 49, 41, 44, 1
}
```

### Копирование объектов и ссылки

Отличий объектов от примитивов заключается в том, что объекты хранятся и копируются «по ссылке», тогда как примитивные значения: строки, числа, логические значения и т.д. – всегда копируются «как целое значение».

**Переменная, которой присвоен объект, хранит не сам объект, а его «адрес в памяти» – другими словами, «ссылку» на него.**

**При копировании переменной объекта копируется ссылка, но сам объект не дублируется.**

```js
let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // изменено по ссылке из переменной "admin"
alert(user.name); // 'Pete', изменения видны по ссылке из переменной "user"
```

**Сравнение по ссылке**

Два объекта равны только в том случае, если это один и тот же объект.

```js
let a = {};
let b = a; // копирование по ссылке
alert( a == b ); // true, обе переменные ссылаются на один и тот же объект
alert( a === b ); // true

//___
let a = {};
let b = {}; // два независимых объекта
alert( a == b ); // false
```

**Клонирование и объединение, Object.assign**

```js
//__1
let user = {
  name: "John",
  age: 30
};

let clone = {}; // новый пустой объект
// давайте скопируем все свойства user в него
for (let key in user) {
  clone[key] = user[key];
}
// теперь clone это полностью независимый объект с тем же содержимым
clone.name = "Pete"; // изменим в нём данные
alert( user.name ); // все ещё John в первоначальном объекте

//__метод Object.assign
let user = { name: "John" };
let permissions1 = { canView: true };
let permissions2 = { canEdit: true };
// копируем все свойства из permissions1 и permissions2 в user
Object.assign(user, permissions1, permissions2);
// теперь user = { name: "John", canView: true, canEdit: true }

//Если скопированное имя свойства уже существует, оно будет перезаписано
let user = { name: "John" };
Object.assign(user, { name: "Pete" });
alert(user.name); // теперь user = { name: "Pete" }

let user = {
  name: "John",
  age: 30
};
let clone = Object.assign({}, user);

//оператора расширения 
clone = {...user}
```

**Вложенное клонирование**

Это называется «глубоким клонированием».

Метод structuredClone(), который позволяет сделать полную копию объекта. К сожалению он поддерживается только современными браузерам.

### Сборка мусора

Основной концепцией управления памятью в JavaScript является принцип достижимости.
- «достижимые» значения – это те, которые доступны или используются.
- Любое другое значение считается достижимым, если оно доступно из корня по ссылке или по цепочке ссылок.
-  Объект становится недостижимым - cборщик мусора удалит эти данные и освободит память.
- Бывший объект  был отсоединён от корня, на него больше нет ссылки, поэтому весь «остров» становится недостижимым и будет удалён.

**Внутренние алгоритмы**

Согласно этому алгоритму, сборщик мусора регулярно выполняет следующие шаги:
- Сборщик мусора «помечает» (запоминает) все корневые объекты.
- Затем он идёт по ним и «помечает» все ссылки из них.
- Затем он идёт по отмеченным объектам и отмечает их ссылки. Все посещённые объекты запоминаются, чтобы в будущем не посещать один и тот же объект дважды.
- …И так далее, пока не будут посещены все достижимые (из корней) ссылки.
- Все непомеченные объекты удаляются.

### Методы объекта, "this"


**Сокращённая запись метода**
```js
user = {
  sayHi: function() {
    alert("Привет");
  }
};

// сокращённая запись выглядит лучше, не так ли?
user = {
  sayHi() { // то же самое, что и "sayHi: function(){...}"
    alert("Привет");
  }
};
```

**Ключевое слово «this» в методах**

- Значение this – это объект «перед точкой», который используется для вызова метода.

```js
let user = {
  name: "John",
  age: 30,
  sayHi() {
    // "this" - это "текущий объект".
    alert(this.name);
  }
};
user.sayHi(); // John
```

**«this» не является фиксированным**

Значение this вычисляется во время выполнения кода, в зависимости от контекста.

Правило простое: если вызывается obj.f(), то во время вызова f, this – это obj.
```js
let user = { name: "John" };
let admin = { name: "Admin" };

function sayHi() {
  alert( this.name );
}
// используем одну и ту же функцию в двух объектах
user.f = sayHi;
admin.f = sayHi;
```

**Вызов без объекта**

В строгом режиме ("use strict") в таком коде значением this будет являться undefined
```js
function sayHi() {
  alert(this);
}
sayHi(); // undefined
```

В нестрогом режиме значением this в таком случае будет глобальный объект window

**У стрелочных функций нет «this»**

```js
let user = {
  firstName: "Ilya",
  sayHi() {
    let arrow = () => alert(this.firstName);
    arrow();
  }
};
user.sayHi(); // Ilya
```

### Конструктор, оператор "new"

Обычный синтаксис {...} позволяет создать только один объект. Но зачастую нам нужно создать множество похожих

**Функция-конструктор**

- Функция-конструктор должна выполняться только с помощью оператора "new"
- Создаётся новый пустой объект, и он присваивается this.
- Выполняется тело функции. Обычно оно модифицирует this, добавляя туда новые свойства.
- Возвращается значение this
```js
function User(name) {
  // this = {};  (неявно)

  // добавляет свойства к this
  this.name = name;
  this.isAdmin = false;

  // return this;  (неявно)
}
let user = new User("Jack");
alert(user.name); // Jack
alert(user.isAdmin); // false
```

Технически любая функция (кроме стрелочных функций, поскольку у них нет this) может использоваться в качестве конструктора.

Если в нашем коде присутствует большое количество строк, создающих один сложный объект, то мы можем обернуть их в функцию-конструктор, которая будет немедленно вызвана, вот так:
```js
let user = new function() {
  this.name = "John";
  this.isAdmin = false;
};
```

**Проверка на вызов в режиме конструктора: new.target**

Используя специальное свойство new.target внутри функции, мы можем проверить, вызвана ли функция при помощи оператора new или без него.
```js
function User() {
  alert(new.target);
}
// без "new":
User(); // undefined
// с "new":
new User(); // function User { ... }

//__
function User(name) {
  if (!new.target) { // в случае, если вы вызвали меня без оператора new
    return new User(name); // ...я добавлю new за вас
  }

  this.name = name;
}
let john = User("John"); // переадресовывает вызов на new User
alert(john.name); // Joh
```

**Возврат значения из конструктора, return**

Return с объектом возвращает этот объект, во всех остальных случаях возвращается this
```js
function BigUser() {
  this.name = "John";
  return { name: "Godzilla" };  // <-- возвращает этот объект
}
alert( new BigUser().name );  // Godzilla, получили этот объект
```

Обычно у конструкторов отсутствует return. Здесь мы упомянули особое поведение

**Создание методов в конструкторе**

```js
function User(name) {
  this.name = name;
  this.sayHi = function() {
    alert( "Меня зовут: " + this.name );
  };
}
let john = new User("John");
john.sayHi(); // Меня зовут: John
/*
john = {
   name: "John",
   sayHi: function() { ... }
}
*/
```
### Опциональная цепочка '?.'

?. немедленно останавливает вычисление, если левая часть не существуе

```js
let user = {}; // пользователь без свойства "address"
alert(user.address.street); // Ошибка!
```

**Опциональная цепочка**

Обратите внимание: синтаксис ?. делает необязательным значение перед ним, но не какое-либо последующее.

```js
let user = {}; // пользователь без адреса
alert( user?.address?.street ); // undefined (без ошибки)
```

Если слишком часто использовать ?., ошибки могут замалчиваться там, где это неуместно, и их будет сложнее отлаживать.

Переменная перед ?. должна быть объявлена
```js
// ReferenceError: user is not defined
user?.address;
```

**Другие варианты применения: ?.(), ?.[]**

Опциональная цепочка ?. — это не оператор, а специальная синтаксическая конструкция, которая также работает с функциями и квадратными скобками.

```js
let userAdmin = {
  admin() {
    alert("Я админ");
  }
};
let userGuest = {};
userAdmin.admin?.(); // Я админ

//__
let key = "firstName";
let user1 = {
  firstName: "John"
};
let user2 = null;
alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined
```

Мы можем использовать "?." для безопасного чтения и удаления, но не для записи Опциональна
```js
let user = null;
user?.name = "John"; // Ошибка, не работает
// то же самое что написать undefined = "John"
```

### Тип данных Symbol

«Символ» представляет собой уникальный идентификатор.
```js
// Создаём новый символ - id
let id = Symbol();

// Создаём символ id с описанием (именем) "id"
//Даже если мы создадим множество символов с одинаковым описанием, это всё равно будут разные символы
let id = Symbol("id");

//Символы не преобразуются автоматически в строки
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string

//необходимо явно преобразовать его с помощью метода .toString()
let id = Symbol("id");
alert(id.toString()); // Symbol(id), теперь работает

//вывести только описание
let id = Symbol("id");
alert(id.description); // id
```

**«Скрытые» свойства**

```js
let user = {
  name: "Вася"
};
let id = Symbol("id");
user[id] = 1;
alert( user[id] ); // мы можем получить доступ к данным по ключу-символу
```

**Символы в литеральном объекте**

```js
let id = Symbol("id");
let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
```

**Символы игнорируются циклом for…in**

- А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства

**Глобальные символы**

- Иногда мы наоборот хотим, чтобы символы с одинаковыми именами были одной сущностью
- Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже
```js
// читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

// читаем его снова и записываем в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

// проверяем -- это один и тот же символ
alert( id === idAgain ); // true

//возвращает его имя .keyFor()
let sym = Symbol.for("name");
alert( Symbol.keyFor(sym) ); // name
```

**Системные символы**

- Symbol.hasInstance
- Symbol.isConcatSpreadable
- Symbol.iterator
- Symbol.toPrimitive
- …и так далее.

### Преобразование объектов в примитивы

**Правила преобразования**
- Не существует преобразования к логическому значению. В логическом контексте все объекты являются true, всё просто. Существует лишь их числовое и строковое преобразование.
- Числовое преобразование происходит, когда мы вычитаем объекты или применяем математические функции.
- Что касается преобразований к строке – оно обычно происходит, когда мы выводим на экран объект при помощи alert(obj) и в подобных контекстах.

**Хинты**

Спецификация явно описывает для каждого оператора, какой ему следует использовать хинт.

-"string"
```js
// вывод
alert(obj);
// используем объект в качестве ключа
anotherObj[obj] = 123;
```
- "number"
```js
// явное преобразование
let num = Number(obj);

// математические (не считая бинарного плюса)
let n = +obj; // унарный плюс
let delta = date1 - date2;

// сравнения больше/меньше
let greater = user1 > user2;
```
- "default" - Происходит редко, когда оператор «не уверен», какой тип ожидать (для некоторых других операторов, обычно объекты реализуют его как "number")

Чтобы выполнить преобразование, JavaScript пытается найти и вызвать три следующих метода объекта:
- Вызвать obj[Symbol.toPrimitive](hint) – метод с символьным ключом Symbol.toPrimitive (системный символ), если такой метод существует,
- Иначе, если хинт равен "string"
попробовать вызвать obj.toString() или obj.valueOf(), смотря какой из них существует.
- Иначе, если хинт равен "number" или "default"
попробовать вызвать obj.valueOf() или obj.toString(), смотря какой из них существует.

**Symbol.toPrimitive**

Если метод Symbol.toPrimitive существует, он используется для всех хинтов, и больше никаких методов не требуется.
```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};
// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```

**toString/valueOf**
- Метод toString возвращает строку "[object Object]".
- Метод valueOf возвращает сам объект.
```js
let user = {name: "John"};
alert(user); // [object Object]
alert(user.valueOf() === user); // true
```

применим эти методы для настройки преобразован
```js
let user = {
  name: "John",
  money: 1000,

  // для хинта равного "string"
  toString() {
    return `{name: "${this.name}"}`;
  },

  // для хинта равного "number" или "default"
  valueOf() {
    return this.money;
  }

};
alert(user); // toString -> {name: "John"}
alert(+user); // valueOf -> 1000
alert(user + 500); // valueOf -> 1500
```

**Преобразование может вернуть любой примитивный тип**

Нет никакого контроля над тем, вернёться

Единственное обязательное условие: эти методы должны возвращать примитив, а не объект

**Дальнейшие преобразования**

```js
let obj = {
  // toString обрабатывает все преобразования в случае отсутствия других методов
  toString() {
    return "2";
  }
};
alert(obj * 2); // 4, объект был преобразован к примитиву "2", затем умножение сделало его числом

//__
let obj = {
  toString() {
    return "2";
  }
};
alert(obj + 2); // "22" ("2" + 2), преобразование к примитиву вернуло строку => конкатенация
```

## Типы данных



