# learn.javascript.ru

## Введение

### Введение в JavaScript

Изначально JavaScript был создан, чтобы «сделать веб-страницы живыми»

Сегодня JavaScript может выполняться не только в браузере, но и на сервере или на любом другом устройстве, которое имеет специальную программу, называющуюся «движком» JavaScript

Движки сложны. Но основы понять легко.
- Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
- Затем он преобразует («компилирует») скрипт в машинный язык.
- После этого машинный код запускается и работает достаточно быстро.

Возможности JavaScript в браузере ограничены ради безопасности пользователя. 
- JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.
- Различные окна/вкладки не знают друг о друге. «Политика одинакового источника».

Как минимум, три сильные стороны JavaScript:
- Полная интеграция с HTML/CSS.
- Простые вещи делаются просто.
- Поддерживается всеми основными браузерами и включён по умолчанию.

### Справочники и спецификации

Спецификация ECMA содержит самую глубокую, детальную и формализованную информацию о JavaScript

MDN (Mozilla) JavaScript Reference – это справочник с примерами и другой информацией. Хороший источник для получения подробных сведений о функциях языка, методах встроенных объектов и так далее.

Таблицы совместимости - https://caniuse.com – таблицы с информацией о поддержке 

### Редакторы кода

Термином IDE (Integrated Development Environment, «интегрированная среда разработки») называют мощные редакторы с множеством функций, которые работают в рамках целого проекта. Как видно из названия, это не просто редактор, а нечто большее.

### Консоль разработчика

Но по умолчанию в браузере ошибки не видны.
Для решения задач такого рода в браузер встроены так называемые «Инструменты разработки».

Нажмите F12

## Основы JavaScript

### Привет, мир!

Для серверных сред (например, Node.js), вы можете выполнить скрипт с помощью команды типа "node my.js"

Тег «script»
```html
 <script>
    alert( 'Привет, мир!' );
 </script>

<!-- Внешние скрипты  -->
<script src="/path/to/script.js"></script>
```
- /path/to/script.js – это абсолютный путь от корневой папки
- можно указать относительный путь от текущей страницы. Например, src="script.js"

### Структура кода

- Инструкции – это синтаксические конструкции и команды, которые выполняют действия
- Инструкции могут отделяться точкой с запятой
- В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку
- В некоторых ситуациях новая строка всё же не означает точку с запятой
```js
alert(3 +
1
+ 2);

//будет ошибка
alert('Hello')
[1, 2].forEach(alert);
//alert('Hello')[1, 2].forEach(alert);
```
- Мы рекомендуем ставить точку с запятой между инструкциями, даже если они отделены переносами строк

**Комментарии**
- Ctrl+/ для однострочного комментария 
- Ctrl+Shift+/ – для многострочных комментариев
- Вложенные комментарии не поддерживаются! Не может быть /*...*/ внутри /*...*/.
```js
// Этот комментарий занимает всю строку
/* Пример с двумя сообщениями.
Это - многострочный комментарий.
*/
```

### Строгий режим — "use strict"

- Убедитесь, что «use strict» находится в начале
- Нет никакого способа отменить use strict
- Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать, они автоматически включают строгий режим
```js
"use strict";
// этот код работает в современном режиме
```

```js
alert("some code");
// "use strict" ниже игнорируется - он должен быть в первой строке
"use strict";
```

### Переменные

Переменная – это «именованное хранилище» для данных. 

```js
let message;
message = 'Hello!';
alert(message); // показывает содержимое переменной

//можем объявить несколько переменных в одной строке
let user = 'John', age = 25, message = 'Hello';

//____
//можем объявить две переменные и скопировать данные из одной в другую
let hello = 'Hello world!';

let message;

// копируем значение 'Hello world' из переменной hello в переменную message
message = hello;

// теперь две переменные содержат одинаковые данные
alert(hello); // Hello world!
alert(message); // Hello world!

//_____
//Повторное объявление вызывает ошибку
let message = "Это";
let message = "Другое"; // SyntaxError: 'message'

//____
//Это плохая практика, которая приводит к ошибке в строгом режиме:
"use strict";
num = 5; // ошибка: num is not defined
```

**Имена переменных**
- Имя переменной должно содержать только буквы, цифры или символы $ и _.
- Первый символ не должен быть цифрой.
- обычно используется верблюжья нотация - myVeryLongName
- дефис '-' не разрешён в имени
- Регистр имеет значение
- Нелатинские буквы разрешены, но не рекомендуются
- Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

**Константы**

- Их нельзя изменить. Попытка сделать это приведёт к ошибке
```js
const myBirthday = '18.04.1982';
myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!

//____
//Константы в верхнем регистре - константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений
const COLOR_RED = "#F00";
```

**Придумывайте правильные имена**

- ясный и понятный смысл
- говорить о том, какие данные в ней хранятся

**Итого**

- let – это современный способ объявления.
- var – это устаревший способ объявления
- const – похоже на let, но значение переменной не может изменяться.

### Типы данных

Есть восемь основных типов данных в JavaScript

**Число**

- представляет как целочисленные значения, так и числа с плавающей точкой
- cуществует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание -
-  существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

```js
let n = 123;
n = 12.345;
alert( 1 / 0 ); // Infinity

//NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции
//Любая математическая операция с NaN возвращает NaN
"не число" / 2 // NaN
alert( NaN + 1 ); 
```

**BigInt**

- все нечетные целые числа, большие чем (253-1), вообще не могут храниться в типе number
- необходимо добавить n в конец

```js
const bigInt = 1234567890123456789012345678901234567890n;
```

**Строка**

```js
let str = "Привет";
let str2 = 'Одинарные кавычки тоже подойдут';
//Обратные же кавычки имеют расширенную функциональность
let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
```

**Булевый (логический) тип**

- true (истина) и false (ложь).

```js
let isGreater = 4 > 1;// true (результатом сравнения будет "да")
```

**Значение «null»**

- представляет собой «ничего», «пусто» или «значение неизвестно».
```js
let age = null;
```

**Значение «undefined»**
- сли переменная объявлена, но ей не присвоено никакого значения
```js
let age;
alert(age); // выведет "undefined"
```

**Объекты и символы**

Тип object (объект) – особенный.
- Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

**Тип symbol**

Используется для создания уникальных идентификаторов в объекта.

**Оператор typeof**

```js
// Обычный синтаксис
typeof 5 // Выведет "number"
// Синтаксис, напоминающий вызов функции (встречается реже),скобки необходимы для определения типа значения, которое получилось в результате выполнения выражения
typeof(5) // Также выведет "number

typeof undefined // "undefined"
typeof 0 // "number"
typeof 10n // "bigint"
typeof true // "boolean"
typeof "foo" // "string"
typeof Symbol("id") // "symbol"
typeof Math // "object"  (1) / Math — это встроенный объект
typeof null // "object"  (2) / Это официально признанная ошибка в typeof
typeof alert // "function"  (3) / alert является функцие / Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function"
```

### Взаимодействие: alert, prompt, confirm

- alert- она показывает сообщение и ждёт, пока пользователь нажмёт кнопку «ОК»
```js
alert("Hello");
```
- prompt - отобразит модальное окно с текстом,default
необязательный второй параметр, который устанавливает начальное значен
```js
let age = prompt('Сколько тебе лет?', 100);
```
- confirm - функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.
```js
let isBoss = confirm("Ты здесь главный?");
alert( isBoss ); // true, если нажата OK
```

### Преобразование типов

**Строковое преобразование**
```js
let value = true;
value = String(value); // теперь value это строка "true
```

**Численное преобразование**

Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.

```js
alert( "6" / "2" ); // 3, строки преобразуются в числа

//явно преобразовать value
let str = "123";
let num = Number(str); // становится числом 1
```

- undefined - NaN
- null - 0
- true / false	1 /  - 0
- string	Пробельные символы (пробелы, знаки табуляции \t, знаки новой строки \n и т. п.) по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.

**Логическое преобразование**

Правило преобразования:
- Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
- Все остальные значения становятся true
```js
alert( Boolean(1) ); // true
alert( Boolean(0) ); // false
```

### Базовые операторы, математика

**Термины: «унарный», «бинарный», «операнд»**

Операнд – то, к чему применяется оператор. 

Унарным называется оператор, который применяется к одному операнду
```js
let x = 1;
x = -x;
```

Бинарным называется оператор, который применяется к двум операндам
```js
y - x
```

**Математика**

- Сложение +,
- Вычитание -,
- Умножение *,
- Деление /,
- Взятие остатка от деления %,
- Возведение в степень **

```js
5 % 2 ; // 1, остаток от деления 5 на 2
2 ** 2 ; // 2² = 4
 4 ** (1/2) ; // 2 (степень 1/2 эквивалентна взятию квадратного корня)
```

### Сложение строк при помощи бинарного +

```js
let s = "моя" + "строка"; // моястрока
'1' + 2 ; // "12"
2 + 2 + '1' ; // будет "41", а не "221"
```

Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
```js
6 - '2' ; // 4, '2'
```

**Приведение к числу, унарный +**

- Если операнд не число, унарный плюс преобразует его в число.
```js
+true ; // 1

let apples = "2";
let oranges = "3";
// оба операнда предварительно преобразованы в числа
alert( +apples + +oranges ); // 5
```

**Приоритет операторов**

В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.

**Присваивание**

Один из самых низких приоритетов: 2
```js
let x = 2 * 2 + 1; // 5
```

Присваивание = возвращает значение
```js
let a = 1;
let b = 2;
let c = 3 - (a = b + 1);
alert( a ); // 3
alert( c ); // 0
```

Присваивание по цепочке
```js
let a, b, c;
a = b = c = 2 + 2;
alert( a ); // 4
alert( b ); // 4
alert( c ); // 4
```

Сокращённая арифметика с присваиванием
```js
let n = 2;
n += 5; // теперь n = 7 (работает как n = n + 5)
n *= 2; // теперь n = 14 (работает как n = n * 
```

**Инкремент/декремент**

Инкремент ++ увеличивает переменную на 1:
```js
let counter = 2;
counter++;        // работает как counter = counter + 1, просто запись короче
```

Декремент -- уменьшает переменную на 1:
```js
let counter = 2;
counter--;        // работает как counter = counter - 1, просто запись короче
```

Операторы ++ и -- могут быть расположены не только после, но и до переменной.
- Когда оператор идёт после переменной — это «постфиксная форма»: counter++,постфиксная форма возвращает старое (до увеличения/уменьшения числа)
```js
let counter = 1;
let a = counter++; // (*) меняем ++counter на counter++
alert(a); // 1
```
- «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
```js
let counter = 1;
let a = ++counter; // (*)
alert(a); // 2
```

Если результат оператора не используется, а нужно только увеличить/уменьшить переменную, тогда без разницы, какую форму использовать.Если хочется тут же использовать результат, то нужна префиксная форма.

Операторы ++/-- могут также использоваться внутри выражений.
```js
let counter = 1;
alert( 2 * ++counter ); 
```

**Побитовые операторы**

Побитовые операторы работают с 32-разрядными целыми числами
- AND(и) ( & )
- OR(или) ( | )
- XOR(побитовое исключающее или) ( ^ )
- NOT(не) ( ~ )
- LEFT SHIFT(левый сдвиг) ( << )
- RIGHT SHIFT(правый сдвиг) ( >> )
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )

**Оператор «запятая»**

- написания более короткого кода
- но возвращается результат только последнего
```js
let a = (1 + 2, 3 + 4);// 7 (результат вычисления 3 + 4)

//Запятая имеет очень низкий приоритет,ниже =
a = 1 + 2, 3 + 4;
alert(a); // 3 

// три операции в одной строке
for (a = 1, b = 3, c = a * b; a < 10; a++) {}
```

### Операторы сравнения

**Результат сравнения имеет логический тип**

- true – означает «да», «верно», «истина».
- false – означает «нет», «неверно», «ложь

```js
2 > 1 ;  // true
```

**Сравнение строк**

- строки сравниваются посимвольно
- К равна К.
- о равна о.
- т больше, чем д. На этом сравнение заканчивается. Первая строка больше.
```js
'Я' > 'А' ; // true
'Коты' > 'Кода' ; // true
```

**Сравнение разных типов**

- При сравнении значений разных типов JavaScript приводит каждое из них к числу.

```js
'2' > 1 ; // true, строка '2' становится числом 2
'01' == 1 ; // true, строка '01' становится числом 1

let a = 0;
Boolean(a); // false
let b = "0";
Boolean(b); // true
a == b; // true
```

**Строгое сравнение**

Оператор строгого равенства === проверяет равенство без приведения типов.
```js
0 == false ; // true
0 === false ; // false, так как сравниваются разные типы
```

**Сравнение с null и undefined**

Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

```js
null === undefined ; // false

null == 0 ; // (2) false
//Сравнения преобразуют null в число
alert( null >= 0 ); // (3) true
```

Значение undefined несравнимо с другими значениями:
- undefined преобразуется в NaN
```js
undefined > 0 ; // false (1)
```

**Не используйте сравнения >= > < <= с переменными, которые могут принимать значения null/undefined, разве что вы полностью уверены в том, что делаете. Если переменная может принимать эти значения, то добавьте для них отдельные проверки.**

### Условное ветвление: if, '?'

**Инструкция «if»**

Инструкция if(...) вычисляет условие в скобках и, если результат true

```js
if (year == 2015) alert( 'Вы правы!' );

if (year == 2015) {
   //...
}
```

**Преобразование к логическому типу**

- if (…) вычисляет выражение в скобках и преобразует результат к логическому типу
- Инструкция if может содержать необязательный блок «else» («иначе»)
- Иногда нужно проверить несколько вариантов условия. Для этого используется блок else if

```js
let year = 2013
if (year < 2015) {
  alert( 'Это слишком рано...' );
} else if (year > 2015) {
  alert( 'Это поздновато' );
} else {
  alert( 'Верно!' );
}
```

**Условный оператор „?“**

- Его также называют тернарный

```js
let accessAllowed = (age > 18) ? true : false;
```

**Несколько операторов „?“**

```js
let message = (age < 3) ? 'Здравствуй, малыш!' :
  (age < 18) ? 'Привет!' :
  (age < 100) ? 'Здравствуйте!' :
  'Какой необычный возраст!';
```

### Логические операторы

- || (ИЛИ)
- && (И) 
- ! (НЕ)
- ?? (Оператор нулевого слияния)

**|| (ИЛИ)**

-  в случае, если какой-либо из аргументов true, он вернёт true, в противоположной ситуации возвращается fals

```js
alert( true || true );   // true
alert( false || true );  // true
alert( true || false );  // true
alert( false || false ); // false
```

**ИЛИ "||" находит первое истинное значение**

- цепочка ИЛИ || возвращает первое истинное значение или последнее, если такое значение не найдено.

```js
undefined || null || 0 ; // 0 (поскольку все ложно, возвращается последнее значение)

//Если бы все переменные были ложными, в качестве результата мы бы наблюдали "Аноним".
let firstName = "";
let lastName = "";
let nickName = "Суперкодер";
alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
```

**||= (Логическое присваивание ИЛИ)**

- Если a ложно, присваивает a значение b
```js
a || (a = b);

//__
let johnHasCar = false;
johnHasCar ||= "У Джона нет машины!"; // то же самое, что false || (johnHasCar = "...")
alert( johnHasCar ); // "У Джона нет машины!"

//можем переписать приведённые выше примеры с использованием обычного if
let johnHasCar = false;
if (johnHasCar == false) {
  johnHasCar = "У Джона нет машины!";
}
alert(johnHasCar); // "У Джона нет машины!"
```

**&& (И)**

```js
//В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false
alert( true && true );   // true
alert( false && true );  // false
alert( true && false );  // false
alert( false && false ); // false
```

Оператор && выполняет следующие действия:
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. - Если результат false, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращается последний.

```js
alert( 1 && 2 && null && 3 ); // null
alert( 1 && 2 && 3 ); // 3
```

Несмотря на то, что вариант с && кажется более коротким, if более нагляден и, как правило, более читабелен. Поэтому мы рекомендуем использовать каждую конструкцию по назначению: использовать if, если нам нужно if, и использовать &&, если нам нужно И.

**&&= (Логическое присваивание И)**

&&= присвоит a значение b только в том случае, если a истинно.

```js
a &&= b; //a && (a = b);
```

**! (НЕ)**

- Сначала приводит аргумент к логическому типу true/false.
- Затем возвращает противоположное значение.

```js
alert( !true ); // false
alert( !0 ); // true
```

В частности, двойное НЕ !! используют для преобразования значений к логическому типу:
```js
alert( !!"непустая строка" ); // true
alert( !!null ); // false
```

### Операторы нулевого слияния и присваивания: '??', '??='

- оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.


Важное различие между ними заключается в том, что:
- || возвращает первое истинное значение.
- ?? возвращает первое определённое значение.
Проще говоря, оператор || не различает false, 0, пустую строку "" и null/undefined. Для него они все одинаковы, т.е. являются ложными значениями. Если первым аргументом для оператора || будет любое из перечисленных значений, то в качестве результата мы получим второй аргумент.

Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.
```js
let height = 0;
alert(height || 100); // 100
alert(height ?? 100); // 0
```

Приоритет оператора ?? такой же, как и у ||. Они оба равны 3 в таблице на MDN.

По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если приоритет явно не указан при помощи круглых скобок.

Можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";
// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```

**Оператор нулевого присваивания (??=)**

??= присвоит x значение y только в том случае, если x не определено (null/undefined).
```js
let userAge = null;
userAge ??= 18;
alert(userAge) // 18
```

### Циклы while и for

**Цикл «while»**

- Код из тела цикла выполняется, пока условие condition истинно
- условие while вычисляется и преобразуется в логическое значение
```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки
```js
while (i) alert(i--);
```

**Цикл «do…while»**

Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

```js
let i = 0;
do {
  alert( i );
  i++;
} while (i < 3);
```

**Цикл «for»**
- начало	let i = 0	Выполняется один раз при входе в цикл
- условие	i < 3	Проверяется перед каждой итерацией цикла.
Если оно вычислится в false, цикл остановится.
- тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.
- шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
```js
for (let i = 0; i < 3; i++) { // выведет 0, затем 1, затем 2
  alert(i);
}
```

**Пропуск частей «for»**

```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}

//__
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
//Это сделает цикл аналогичным while (i < 3).
```

**Прерывание цикла: «break»**

Полностью прекращает выполнение цикла

```js
let sum = 0;

while (true) {
  let value = +prompt("Введите число", '');
  if (!value) break; // (*)
  sum += value;
}
alert( 'Сумма: ' + sum );
```

**Переход к следующей итерации: continue**

При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

```js
for (let i = 0; i < 10; i++) {
  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;
  alert(i); // 1, затем 3, 5, 7, 9
}
```

**Нельзя использовать break/continue справа от оператора „?“**

синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором ?
```js
(i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
```

**Метки для break/continue**

Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

```js
// outer:
// for (let i = 0; i < 3; i++) { ... }
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    //// не прыгает к метке ниже
    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}
```

### Конструкция "switch"

Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

```js
switch (a) {
  case 3:
    alert( 'Маловато' );
    break;
  case 4:
    alert( 'В точку!' );
  case 5:
    alert( 'Перебор' );
    break;
  default:
    alert( "Нет таких значений" );
}

//Любое выражение может быть аргументом
switch (+a) {
  case b + 1:
    alert("Выполнится, т.к. значением +a будет 1, что в точности равно b+1");
    break;

  default:
    alert("Это не выполнится");
}
```

**Группировка «case»**

```js
switch (a) {
  case 4:
    alert('Правильно!');
    break;

  case 3: // (*) группируем оба case
  case 5:
    alert('Неправильно!');
    alert("Может вам посетить урок математики?");
    break;

  default:
    alert('Результат выглядит странновато. Честно.');
}
```

**Тип имеет значение**

Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

### Функции

- Повторять одно и то же действие во многих частях программы.
- Одно из главных предназначений функций: избавление от дублирования кода.

**Объявление функции**

```js
function имя(параметры) {
  //...тело...
}
```

**Локальные переменные**

Переменные, объявленные внутри функции, видны только внутри этой функции
```js
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная
  alert( message );
}
showMessage(); // Привет, я JavaScript!
alert( message ); // <-- будет ошибка, т.к. переменная видна только внутри функции
```

**Внешние переменные**

У функции есть доступ к внешним переменным

Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

```js
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
showMessage(); // Привет, Вася
```

**Параметры**

- Функция всегда получает только копию значения
- Параметр – это переменная, указанная в круглых скобках в объявлении функции.
- Аргумент – это значение, которое передаётся функции при её вызове.
```js
function showMessage(from, text) { // параметры: from, text
  alert(from + ': ' + text);
}
```

**Значения по умолчанию**

```js
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}

function showMessage(from, text = anotherFunction()) {
  // anotherFunction() выполнится только если не передан text
  // результатом будет значение text
}

//параметров по умолчанию в ранних версиях JavaScript
function showMessage(from, text) {
  if (text === undefined) {
    text = 'текст не добавлен';
  }
}

function showMessage(from, text) {
  text = text || 'текст не добавлен';
}
```

**Возврат значения**

Функция может вернуть результат

Директива return может находиться в любом месте тела функции. Как только выполнение доходит до этого места, функция останавливается, и значение возвращается в вызвавший её код

```js
function sum(a, b) {
  return a + b;
}
let result = sum(1, 2); // 3

function checkAge(age) {
  if (age >= 18) {
    return true;
  } else {
    return confirm('А родители разрешили?');
  }
}

//Возможно использовать return и без значения. Это приведёт к немедленному выходу из функции
//Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined
function showMovie(age) {
  if ( !checkAge(age) ) {
    return;//undefined
  }
}

//Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return
return (
  some + long + expression
  + or +
  whatever * f(a) + f(b)
  )
```

**Bыбор имени функции**

Функция – это действие. Поэтому имя функции обычно является глаголом
Функции, начинающиеся с…
- "get…" – возвращают значение,
- "calc…" – что-то вычисляют,
- "create…" – что-то создают,
- "check…" – что-то проверяют и возвращают логическое значение, и т.д.

**Одна функция – одно действие**

Функции должны быть короткими и делать только что-то одно.

### Function Expression

Функциональное Выражение
- создать функцию и поместить её в переменную

```js
let sayHi = function() {
  alert( "Привет" );
};
```

**Функция – это значение**

```js
function sayHi() {
  alert( "Привет" );
}
alert( sayHi ); // выведет код функции

//Мы можем скопировать функцию в другую переменную
let func = sayHi;    // (2) копируем
func(); // Привет     // (3) вызываем копию (работает)!
sayHi(); // Привет 

//выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi
```

**Функции-«колбэки»**

Аргументы showOk и showCancel функции ask называются функциями-колбэками или просто колбэками.

```js
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}
function showOk() {
  alert( "Вы согласны." );
}
function showCancel() {
  alert( "Вы отменили выполнение." );
}
// использование: функции showOk, showCancel передаются в качестве аргументов ask
ask("Вы согласны?", showOk, showCancel);

//__
//Здесь функции объявляются прямо внутри вызова ask(...). У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи ask
function ask(question, yes, no) {
  if (confirm(question)) yes()
  else no();
}

ask(
  "Вы согласны?",
  function() { alert("Вы согласились."); },
  function() { alert("Вы отменили выполнение."); }
);
```

**Function Expression в сравнении с Function Declaration**

- Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.
- Function Declaration может быть вызвана раньше, чем она объявлена.
- Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них.

```js
sayHi("Вася"); // Привет, Вася

function sayHi(name) {
  alert( `Привет, ${name}` );
}
```

В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.
```js
//Function Declaration видимо только внутри блока код
if (age < 18) {
  function welcome() {
    alert("Привет!");
  }
} else {
  function welcome() {
    alert("Здравствуйте!");
  }
}
// ...не работает
welcome(); // Error: welcome is not defined

//___Верным подходом будет объявленние снаружи
let welcome;
if (age < 18) {
  welcome = function() {
    alert("Привет!");
  };
} else {
  welcome = function() {
    alert("Здравствуйте!");
  };
}
welcome(); 
```

### Стрелочные функции, основы

```js
let sum = (a, b) => a + b;

//Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить
let double = n => n * 2;
```

**Многострочные стрелочные функции**

```js
let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
  let result = a + b;
  return result; // если мы используем фигурные скобки, то нам нужно явно указать "return"
};
```

## Качество кода

### Отладка в браузере

Отладка – это процесс поиска и исправления ошибок в скрипте. 

**Панель «Исходный код» («Sources»)**

- В зоне File Navigator (панель для навигации файлов) 
- Зона Code Editor
- зона JavaScript Debuggin

**Точки останова (breakpoints)**
- Точка останова – это участок кода, где отладчик автоматически приостановит исполнение JavaScript
- щёлкните на номере строки, вы поставили точку останова
- Пока исполнение поставлено «на паузу», мы можем просмотреть текущие значения переменных

**Команда debugger**

```js
function hello(name) {
  let phrase = `Привет, ${name}!`;
  debugger;  // <-- тут отладчик остановится
  say(phrase);
}
```

**Остановимся и оглядимся**

- Для начала отладки (после того, как мы поставили точки останова) проще всего её перезагрузить
- Watch– показывает текущие значения для любых выражений
- Call Stack – показывает цепочку вложенных вызовов
- Scope показывает текущие переменные
- В Global перечисляются глобальные переменные

**Пошаговое выполнение скрипта**

-  –> «Resume»: продолжить выполнение, быстрая клавиша F8.Выполнение кода возобновилось, дошло до другой точки останова
- «Step»: выполнить следующую команду, быстрая клавиша F9.Выполняет следующую инструкцию,«Step» игнорирует асинхронные действия
- «Step over»: выполнить следующую команду, но не заходя внутрь функции, быстрая клавиша F10, выполняет вызов вложенной функции незаметно для нас, пропуская её внутренний код.
- «Step into», быстрая клавиша F11.«Step into» входит в их код, ожидая асинхронные действия
- «Step out»: продолжить выполнение до завершения текущей функции, быстрая клавиша Shift+F11.Продолжает выполнение и останавливает его в самой последней строке текущей функции.
- активировать/деактивировать все точки останова(breakpoints).
- включить/отключить автоматическую паузу в случае ошибки.

**Логирование**

Чтобы вывести что-то на консоль из нашего кода, существует функция console.log.
```js
console.log("value,", i);
```

### Советы по стилю кода

```js

```